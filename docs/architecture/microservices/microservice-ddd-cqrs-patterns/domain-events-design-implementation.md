---
title: Domänenereignisse. Entwurf und Implementierung
description: .NET-Microservicearchitektur für .NET-Containeranwendungen | Übersicht über Domänenereignisse, ein Schlüsselkonzept zum Herstellen der Kommunikation zwischen Aggregaten
ms.date: 10/08/2018
ms.openlocfilehash: 651d9cb98444c0729b97f523cc3d688f0f8d51d5
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 09/24/2020
ms.locfileid: "91173367"
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="92ad3-104">Domänenereignisse: Entwurf und Implementierung</span><span class="sxs-lookup"><span data-stu-id="92ad3-104">Domain events: design and implementation</span></span>

<span data-ttu-id="92ad3-105">Verwenden Sie Domänenereignisse, um explizit Nebenwirkungen von Änderungen in Ihrer Domäne zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="92ad3-105">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="92ad3-106">Unter Verwendung der DDD-Terminologie bedeutet dies kurz gesagt, dass Sie Domänenereignisse verwenden sollten, um Nebenwirkungen explizit aggregatübergreifend zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="92ad3-106">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="92ad3-107">Verwenden Sie optional für eine bessere Skalierbarkeit und weniger Auswirkungen in Datenbanksperren „Eventual Consistency“ zwischen Aggregaten in der gleichen Domäne.</span><span class="sxs-lookup"><span data-stu-id="92ad3-107">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="92ad3-108">Was ist ein Domänenereignis?</span><span class="sxs-lookup"><span data-stu-id="92ad3-108">What is a domain event?</span></span>

<span data-ttu-id="92ad3-109">Ein Ereignis ist etwas, das in der Vergangenheit geschehen ist.</span><span class="sxs-lookup"><span data-stu-id="92ad3-109">An event is something that has happened in the past.</span></span> <span data-ttu-id="92ad3-110">Ein Domänenereignis ist ein Ereignis, das in der Domäne eingetreten ist, und von dem Sie möchten, dass andere Teile der gleichen Domäne (prozessintern) Kenntnis davon nehmen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-110">A domain event is, something that happened in the domain that you want other parts of the same domain (in-process) to be aware of.</span></span> <span data-ttu-id="92ad3-111">Die benachrichtigten Teile reagieren in der Regel auf Ereignisse.</span><span class="sxs-lookup"><span data-stu-id="92ad3-111">The notified parts usually react somehow to the events.</span></span>

<span data-ttu-id="92ad3-112">Ein wichtiger Vorteil von Domänenereignissen besteht darin, dass Nebenwirkungen explizit ausgedrückt werden können.</span><span class="sxs-lookup"><span data-stu-id="92ad3-112">An important benefit of domain events is that side effects can be expressed explicitly.</span></span>

<span data-ttu-id="92ad3-113">Wenn Sie beispielsweise nur Entity Framework verwenden und auf ein Ereignis reagieren müssen, sollten Sie in der Nähe des Ereignisauslösers alles Erforderliche codieren.</span><span class="sxs-lookup"><span data-stu-id="92ad3-113">For example, if you're just using Entity Framework and there has to be a reaction to some event, you would probably code whatever you need close to what triggers the event.</span></span> <span data-ttu-id="92ad3-114">So wird die Regel implizit mit dem Code gekoppelt. Sie müssen sich den Code ansehen, um zu erkennen, dass die Regel dort implementiert ist.</span><span class="sxs-lookup"><span data-stu-id="92ad3-114">So the rule gets coupled, implicitly, to the code, and you have to look into the code to, hopefully, realize the rule is implemented there.</span></span>

<span data-ttu-id="92ad3-115">Andererseits macht die Verwendung von Domänenereignissen das Konzept explizit, weil ein `DomainEvent` und mindestens ein `DomainEventHandler` involviert sind.</span><span class="sxs-lookup"><span data-stu-id="92ad3-115">On the other hand, using domain events makes the concept explicit, because there is a `DomainEvent` and at least one `DomainEventHandler` involved.</span></span>

<span data-ttu-id="92ad3-116">Wenn beispielsweise in der Anwendung eShopOnContainers beim Erstellen einer Bestellung der Benutzer zum Käufer wird, wird ein `OrderStartedDomainEvent` ausgelöst und im `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler` verarbeitet, sodass das zugrunde liegende Konzept offensichtlich ist.</span><span class="sxs-lookup"><span data-stu-id="92ad3-116">For example, in the eShopOnContainers application, when an order is created, the user becomes a buyer, so an `OrderStartedDomainEvent` is raised and handled in the `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`, so the underlying concept is evident.</span></span>

<span data-ttu-id="92ad3-117">Kurz gesagt: Mit Domänenereignissen können Sie die Domänenregeln ausdrücklich in der ubiquitären Sprache ausdrücken, die von den Domänenexperten bereitgestellt wurde.</span><span class="sxs-lookup"><span data-stu-id="92ad3-117">In short, domain events help you to express, explicitly, the domain rules, based in the ubiquitous language provided by the domain experts.</span></span> <span data-ttu-id="92ad3-118">Domänenereignisse ermöglichen auch eine bessere Trennung der Aufgaben zwischen Klassen in der gleichen Domäne.</span><span class="sxs-lookup"><span data-stu-id="92ad3-118">Domain events also enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="92ad3-119">Genau wie bei einer Datenbanktransaktion ist es wichtig sicherzustellen, dass entweder alle Vorgänge, die sich auf ein Domänenereignis beziehen, erfolgreich beendet werden, oder keiner davon.</span><span class="sxs-lookup"><span data-stu-id="92ad3-119">It's important to ensure that, just like a database transaction, either all the operations related to a domain event finish successfully or none of them do.</span></span>

<span data-ttu-id="92ad3-120">Domänenereignisse ähneln Ereignissen im Messagingstil, unterscheiden sich jedoch in einem wichtigen Punkt.</span><span class="sxs-lookup"><span data-stu-id="92ad3-120">Domain events are similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="92ad3-121">Beim echten Messaging, beim Message Queuing, bei Nachrichtenbrokern oder bei einem Service Bus mit AMQP wird eine Nachricht immer asynchron gesendet und kommuniziert prozess- und computerübergreifend.</span><span class="sxs-lookup"><span data-stu-id="92ad3-121">With real messaging, message queuing, message brokers, or a service bus using AMQP, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="92ad3-122">Dies ist hilfreich beim Integrieren von mehreren Kontextgrenzen, von Microservices oder sogar von verschiedenen Anwendungen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="92ad3-123">Mit Domänenereignissen soll ein Ereignis über den Domänenvorgang ausgelöst werden, den Sie gerade ausführen, aber alle Nebenwirkungen sollen in der gleichen Domäne auftreten.</span><span class="sxs-lookup"><span data-stu-id="92ad3-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="92ad3-124">Die Domänenereignisse und ihre Nebenwirkungen (die später ausgelösten Aktionen, die vom Ereignishandler verwaltet werden) sollten fast unmittelbar, in der Regel „In-Process“ und in der gleichen Domäne auftreten.</span><span class="sxs-lookup"><span data-stu-id="92ad3-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="92ad3-125">Daher könnten Domänenereignisse synchron oder asynchron sein.</span><span class="sxs-lookup"><span data-stu-id="92ad3-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="92ad3-126">Integrationsereignisse dagegen sollten immer asynchron sein.</span><span class="sxs-lookup"><span data-stu-id="92ad3-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="92ad3-127">Domänenereignisse im Vergleich zu Integrationsereignissen</span><span class="sxs-lookup"><span data-stu-id="92ad3-127">Domain events versus integration events</span></span>

<span data-ttu-id="92ad3-128">Semantisch gesehen sind Domänen- und Integrationsereignisse das gleiche: Benachrichtigungen über etwas, das soeben aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="92ad3-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="92ad3-129">Ihre Implementierung muss sich jedoch unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-129">However, their implementation must be different.</span></span> <span data-ttu-id="92ad3-130">Domänenereignisse sind einfach per Push übertragene Nachrichten an einen Domänenereignisverteiler, der als In-Memory-Vermittler auf der Grundlage eines IoC-Containers oder einer anderen Methode implementiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="92ad3-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="92ad3-131">Andererseits sollen mit Integrationsereignissen Transaktionen mit ausgeführtem Commit und Updates für zusätzliche Subsysteme weitergegeben werden, wobei es keine Rolle spielt, ob es sich um Microservices, Kontextgrenzen oder externe Anwendungen handelt.</span><span class="sxs-lookup"><span data-stu-id="92ad3-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="92ad3-132">Sie sollten daher nur auftreten, wenn die Entität erfolgreich beibehalten wird, denn andernfalls ist es, als hätte der gesamte Vorgang nie stattgefunden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-132">Hence, they should occur only if the entity is successfully persisted, otherwise it's as if the entire operation never happened.</span></span>

<span data-ttu-id="92ad3-133">Wie bereits erwähnt, müssen Integrationsereignisse auf der asynchronen Kommunikation zwischen mehreren Microservices (andere Kontextgrenzen) oder sogar externen Systemen/Anwendungen basieren.</span><span class="sxs-lookup"><span data-stu-id="92ad3-133">As mentioned before, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span>

<span data-ttu-id="92ad3-134">Die Ereignisbusschnittstelle benötigt daher eine Infrastruktur, die die prozessübergreifende und verteilte Kommunikation zwischen potenziellen Remotediensten ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="92ad3-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="92ad3-135">Sie kann auf einem kommerziellen Service Bus, Warteschlangen, einer freigegebenen Datenbank, die als Postfach verwendet wird, oder einem anderen verteilten und idealerweise Push-basierten Messagingsystem basieren.</span><span class="sxs-lookup"><span data-stu-id="92ad3-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="92ad3-136">Domänenereignisse sind eine bevorzugte Methode zum Auslösen von Nebenwirkungen über mehrere Aggregate innerhalb der gleichen Domäne</span><span class="sxs-lookup"><span data-stu-id="92ad3-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="92ad3-137">Wenn die Ausführung eines Befehls im Zusammenhang mit einer Aggregatinstanz voraussetzt, dass weitere Domänenregeln auf einem oder mehreren zusätzlichen Aggregaten ausgeführt werden, sollten Sie die Nebenwirkungen so entwerfen und implementieren, dass sie von Domänenereignissen ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="92ad3-138">Abbildung 7-14 veranschaulicht einen der wichtigsten Anwendungsfälle: Ein Domänenereignis soll verwendet werden, um Zustandsänderungen über mehrere Aggregate innerhalb des gleichen Domänenmodells wiederzugeben.</span><span class="sxs-lookup"><span data-stu-id="92ad3-138">As shown in Figure 7-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![Diagramm, das ein Domänenereignis zeigt, das Daten zu einem Käufer-Aggregat steuert.](./media/domain-events-design-implementation/domain-model-ordering-microservice.png)

<span data-ttu-id="92ad3-140">**Abbildung 7-14**.</span><span class="sxs-lookup"><span data-stu-id="92ad3-140">**Figure 7-14**.</span></span> <span data-ttu-id="92ad3-141">Domänenereignisse zum Erzwingen der Konsistenz zwischen mehreren Aggregaten in der gleichen Domäne</span><span class="sxs-lookup"><span data-stu-id="92ad3-141">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="92ad3-142">In Abbildung 7-14 wird gezeigt, wie die Konsistenz zwischen Aggregaten durch Domänenereignisse erzielt wird.</span><span class="sxs-lookup"><span data-stu-id="92ad3-142">Figure 7-14 shows how consistency between aggregates is achieved by domain events.</span></span> <span data-ttu-id="92ad3-143">Wenn der Benutzer eine Bestellung initiiert, sendet das Order-Aggregat ein `OrderStarted`-Domänenereignis.</span><span class="sxs-lookup"><span data-stu-id="92ad3-143">When the user initiates an order, the Order Aggregate sends an `OrderStarted` domain event.</span></span> <span data-ttu-id="92ad3-144">Das OrderStarted-Domänenereignis wird vom Buyer-Aggregat verarbeitet, um ein Käuferobjekt im Microservice für Bestellungen zu erstellen. Dies erfolgt auf Grundlage der ursprünglichen Benutzerinformationen aus dem Identitäts-Microservice (mit Informationen, die im CreateOrder-Befehl bereitgestellt werden).</span><span class="sxs-lookup"><span data-stu-id="92ad3-144">The OrderStarted domain event is handled by the Buyer Aggregate to create a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span>

<span data-ttu-id="92ad3-145">Alternativ kann der Aggregatstamm für Ereignisse abonniert werden, die von Mitgliedern seiner Aggregate ausgelöst werden (untergeordnete Entitäten).</span><span class="sxs-lookup"><span data-stu-id="92ad3-145">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="92ad3-146">Jede untergeordnete OrderItem-Entität kann beispielsweise ein Ereignis auslösen, wenn der Artikelpreis über einem bestimmten Betrag liegt oder der Produktartikelbetrag zu hoch ist.</span><span class="sxs-lookup"><span data-stu-id="92ad3-146">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="92ad3-147">Der Aggregatstamm kann dann diese Ereignisse empfangen und eine globale Berechnung oder Aggregation durchführen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-147">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="92ad3-148">Es ist wichtig zu verstehen, dass diese ereignisbasierte Kommunikation nicht direkt in den Aggregaten implementiert ist, d.h. Sie müssen Domänenereignishandler implementieren.</span><span class="sxs-lookup"><span data-stu-id="92ad3-148">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span>

<span data-ttu-id="92ad3-149">Die Handhabung der Domänenereignisse ist für eine Anwendung relevant.</span><span class="sxs-lookup"><span data-stu-id="92ad3-149">Handling the domain events is an application concern.</span></span> <span data-ttu-id="92ad3-150">Die Domänenmodellebene sollte sich nur auf die Domänenlogik konzentrieren, d.h. auf Dinge, die ein Domänenexperte versteht, und nicht auf die Anwendungsinfrastruktur wie Handler und Nebenwirkungspersistenz-Aktionen mithilfe von Repositorys.</span><span class="sxs-lookup"><span data-stu-id="92ad3-150">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="92ad3-151">Daher ist die Ebene der Anwendungsschicht der Ort, an dem Domänenereignishandler Aktionen auslösen, wenn ein Domänenereignis ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="92ad3-151">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="92ad3-152">Domänenereignisse können auch verwendet werden, um eine beliebige Anzahl von Anwendungsaktionen auszulösen. Sie müssen, was noch wichtiger ist, offen sein, um diese Anzahl in der Zukunft entkoppelt zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-152">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="92ad3-153">Wenn beispielsweise die Bestellung gestartet wird, kann es sinnvoll sein, ein Domänenereignis zu veröffentlichen, um diese Informationen an andere Aggregate weiterzuleiten oder sogar Anwendungsaktionen wie Benachrichtigungen auszulösen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-153">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="92ad3-154">Von zentraler Bedeutung ist hier die offene Anzahl auszuführender Aktionen, wenn ein Domänenereignis auftritt.</span><span class="sxs-lookup"><span data-stu-id="92ad3-154">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="92ad3-155">Letztendlich werden die Aktionen und Regeln in der Domäne und der Anwendung erweitert.</span><span class="sxs-lookup"><span data-stu-id="92ad3-155">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="92ad3-156">Die Komplexität oder die Anzahl von Nebenwirkungsaktionen eines Ereignisses erhöhen sich. Wenn Ihr Code jedoch stark gekoppelt wurde (d. h. bestimmte Objekte werden mit `new` erstellt), müssen Sie jedes Mal den ausgeführten und getesteten Code ändern, wenn Sie eine neue Aktion hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-156">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with "glue" (that is, creating specific objects with `new`), then every time you needed to add a new action you would also need to change working and tested code.</span></span>

<span data-ttu-id="92ad3-157">Diese Änderung könnte zu neuen Fehlern führen. Außerdem widerspricht dieser Ansatz dem [Offen/Geschlossen-Prinzip](https://en.wikipedia.org/wiki/Open/closed_principle) von [SOLID](https://en.wikipedia.org/wiki/SOLID).</span><span class="sxs-lookup"><span data-stu-id="92ad3-157">This change could result in new bugs and this approach also goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID).</span></span> <span data-ttu-id="92ad3-158">Darüber hinaus wächst dann auch die ursprüngliche Klasse ständig, die die Vorgänge orchestriert, was dem [Prinzip der einzigen Verantwortung](https://en.wikipedia.org/wiki/Single_responsibility_principle) widerspricht.</span><span class="sxs-lookup"><span data-stu-id="92ad3-158">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="92ad3-159">Wenn Sie Domänenereignisse verwenden, können Sie andererseits eine differenzierte und entkoppelte Implementierung erstellen, indem Sie die Aufgaben mit folgender Methode trennen:</span><span class="sxs-lookup"><span data-stu-id="92ad3-159">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1. <span data-ttu-id="92ad3-160">Senden Sie einen Befehl (z.B. CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="92ad3-160">Send a command (for example, CreateOrder).</span></span>
2. <span data-ttu-id="92ad3-161">Empfangen Sie den Befehl in einem Befehlshandler.</span><span class="sxs-lookup"><span data-stu-id="92ad3-161">Receive the command in a command handler.</span></span>
   - <span data-ttu-id="92ad3-162">Führen Sie eine Transaktion eines einzelnen Aggregats aus.</span><span class="sxs-lookup"><span data-stu-id="92ad3-162">Execute a single aggregate's transaction.</span></span>
   - <span data-ttu-id="92ad3-163">(Optional) Lösen Sie die Domänenereignisse für Nebenwirkungen aus (z.B. OrderStartedDomainEvent).</span><span class="sxs-lookup"><span data-stu-id="92ad3-163">(Optional) Raise domain events for side effects (for example, OrderStartedDomainEvent).</span></span>
3. <span data-ttu-id="92ad3-164">Behandeln Sie die Domänenereignisse (im aktuellen Prozess), die eine offene Anzahl von Nebenwirkungen in mehreren Aggregaten oder Anwendungsaktionen ausführen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-164">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="92ad3-165">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="92ad3-165">For example:</span></span>
   - <span data-ttu-id="92ad3-166">Überprüfen oder erstellen Sie Käufer und Zahlungsmethode.</span><span class="sxs-lookup"><span data-stu-id="92ad3-166">Verify or create buyer and payment method.</span></span>
   - <span data-ttu-id="92ad3-167">Erstellen und senden Sie ein zugehöriges Integrationsereignis an den Ereignisbus, um Zustände über Microservices zu übertragen oder externe Aktionen auszulösen, z.B. Senden einer E-Mail an den Käufer.</span><span class="sxs-lookup"><span data-stu-id="92ad3-167">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
   - <span data-ttu-id="92ad3-168">Behandeln Sie andere Nebenwirkungen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-168">Handle other side effects.</span></span>

<span data-ttu-id="92ad3-169">Wie Abbildung 7-15 zeigt, können Sie ausgehend vom selben Domänenereignis mehrere Aktionen im Zusammenhang mit anderen Aggregaten in der Domäne oder zusätzliche Anwendungsaktionen handhaben, die Sie über Microservices ausführen müssen, wobei eine Verbindung mit Integrationsereignissen und dem Ereignisbus hergestellt wird.</span><span class="sxs-lookup"><span data-stu-id="92ad3-169">As shown in Figure 7-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![Diagramm, das ein Domänenereignis zeigt, das Daten an mehrere Ereignishandler übergibt.](./media/domain-events-design-implementation/aggregate-domain-event-handlers.png)

<span data-ttu-id="92ad3-171">**Abbildung 7-15**.</span><span class="sxs-lookup"><span data-stu-id="92ad3-171">**Figure 7-15**.</span></span> <span data-ttu-id="92ad3-172">Behandlung mehrerer Aktionen pro Domäne</span><span class="sxs-lookup"><span data-stu-id="92ad3-172">Handling multiple actions per domain</span></span>

<span data-ttu-id="92ad3-173">Es kann mehrere Handler für das gleiche Domänenereignis in der Anwendungsschicht geben. Ein Handler kann die Konsistenz zwischen Aggregaten auflösen, und ein anderer Handler kann ein Integrationsereignis veröffentlichen, damit andere Microservices es verwenden können.</span><span class="sxs-lookup"><span data-stu-id="92ad3-173">There can be several handlers for the same domain event in the Application Layer, one handler can solve consistency between aggregates and another handler can publish an integration event, so other microservices can do something with it.</span></span> <span data-ttu-id="92ad3-174">Die Ereignishandler befinden sich in der Regel in der Anwendungsschicht, da Sie Infrastrukturobjekte, z. B. Repositorys oder eine Anwendungs-API, für das Microserviceverhalten verwenden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-174">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice's behavior.</span></span> <span data-ttu-id="92ad3-175">In dieser Hinsicht ähneln Ereignishandler Befehlshandlern, und beide sind Teil der Anwendungsschicht.</span><span class="sxs-lookup"><span data-stu-id="92ad3-175">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="92ad3-176">Der wichtige Unterschied besteht darin, dass ein Befehl nur einmal verarbeitet werden soll.</span><span class="sxs-lookup"><span data-stu-id="92ad3-176">The important difference is that a command should be processed only once.</span></span> <span data-ttu-id="92ad3-177">Ein Domänenereignis wird möglicherweise nur null (0) oder *n*-mal verarbeitet, da es von mehreren Empfängern oder Ereignishandlern mit einem anderen Zweck für jeden Handler empfangen werden kann.</span><span class="sxs-lookup"><span data-stu-id="92ad3-177">A domain event could be processed zero or *n* times, because it can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="92ad3-178">Wenn Sie eine offene Anzahl von Handlern pro Domänenereignis verwenden, können Sie beliebig viele Domänenregeln hinzufügen, ohne dass der aktuelle Code beeinträchtigt wird.</span><span class="sxs-lookup"><span data-stu-id="92ad3-178">Having an open number of handlers per domain event allows you to add as many domain rules as needed, without affecting  current code.</span></span> <span data-ttu-id="92ad3-179">Das Implementieren der folgenden Geschäftsregel kann sich beispielsweise ebenso einfach gestalten wie das Hinzufügen von einigen Ereignishandlern oder auch nur einem Ereignishandler:</span><span class="sxs-lookup"><span data-stu-id="92ad3-179">For instance, implementing the following business rule might be as easy as adding a few event handlers (or even just one):</span></span>

> <span data-ttu-id="92ad3-180">Wenn der im Rahmen einen beliebigen Anzahl von Bestellungen von einem Kunden im Store für Einkäufe ausgegebene Gesamtbetrag 6.000 Euro überschreitet, wird ein Rabatt von 10 % auf jede neue Bestellung angewendet, und der Kunde wird per E-Mail über diesen Rabatt für zukünftige Bestellungen benachrichtigt.</span><span class="sxs-lookup"><span data-stu-id="92ad3-180">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implement-domain-events"></a><span data-ttu-id="92ad3-181">Implementieren von Domänenereignissen</span><span class="sxs-lookup"><span data-stu-id="92ad3-181">Implement domain events</span></span>

<span data-ttu-id="92ad3-182">In C# ist ein Domänenereignis eine Daten enthaltende Struktur oder Klasse, z.B. ein DTO, mit allen Informationen zu den Ereignissen in der Domäne, wie das folgende Beispiel veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="92ad3-182">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : INotification
{
    public string UserId { get; }
    public int CardTypeId { get; }
    public string CardNumber { get; }
    public string CardSecurityNumber { get; }
    public string CardHolderName { get; }
    public DateTime CardExpiration { get; }
    public Order Order { get; }

    public OrderStartedDomainEvent(Order order,
                                   int cardTypeId, string cardNumber,
                                   string cardSecurityNumber, string cardHolderName,
                                   DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="92ad3-183">Dies ist im Wesentlichen eine Klasse, die die Daten enthält, die im Zusammenhang mit dem OrderStarted-Ereignis stehen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-183">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="92ad3-184">Im Hinblick auf die ubiquitäre Sprache der Domäne muss der Klassenname des Ereignisses als Verb in der Vergangenheitsform, z.B. OrderStartedDomainEvent oder OrderShippedDomainEvent, dargestellt werden, da ein Ereignis etwas ist, das in der Vergangenheit aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="92ad3-184">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="92ad3-185">Auf diese Weise wird das Domänenereignis in dem Microservice für Bestellungen in eShopOnContainers implementiert.</span><span class="sxs-lookup"><span data-stu-id="92ad3-185">That's how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="92ad3-186">Wie bereits erwähnt, ist ein wichtiges Merkmal von Ereignissen, dass es nicht geändert werden soll, da es etwas ist, das in der Vergangenheit aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="92ad3-186">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="92ad3-187">Daher muss es eine unveränderliche Klasse sein.</span><span class="sxs-lookup"><span data-stu-id="92ad3-187">Therefore, it must be an immutable class.</span></span> <span data-ttu-id="92ad3-188">Im obigen Code sehen Sie, dass die Eigenschaften schreibgeschützt sind.</span><span class="sxs-lookup"><span data-stu-id="92ad3-188">You can see in the previous code that the properties are read-only.</span></span> <span data-ttu-id="92ad3-189">Es gibt keine Möglichkeit, das Objekt zu aktualisieren. Sie können die entsprechenden Werte nur beim Erstellen festlegen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-189">There's no way to update the object, you can only set values when you create it.</span></span>

<span data-ttu-id="92ad3-190">Wichtig: Wenn Domänenereignisse asynchron mit einer Warteschlange verarbeitet werden, die eine Serialisierung und Deserialisierung der Ereignisobjekte erfordert, müssen die Eigenschaften auf „privat“ statt „schreibgeschützt“ festgelegt werden, damit der Deserialisierer die Werte beim Entfernen aus der Warteschlange zuweisen kann.</span><span class="sxs-lookup"><span data-stu-id="92ad3-190">It's important to highlight here that if domain events were to be handled asynchronously, using a queue that required serializing and deserializing the event objects, the properties would have to be "private set" instead of read-only, so the deserializer would be able to assign the values upon dequeuing.</span></span> <span data-ttu-id="92ad3-191">Das ist kein Problem im Microservice für Bestellungen, da das Domänenereignis „Veröffentlichen/Abonnieren“ synchron über MediatR implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="92ad3-191">This is not an issue in the Ordering microservice, as the domain event pub/sub is implemented synchronously using MediatR.</span></span>

### <a name="raise-domain-events"></a><span data-ttu-id="92ad3-192">Auslösen von Domänenereignissen</span><span class="sxs-lookup"><span data-stu-id="92ad3-192">Raise domain events</span></span>

<span data-ttu-id="92ad3-193">Die nächste Frage lautet, wie ein Domänenereignis ausgelöst wird, damit es seine zugehörigen Ereignishandler erreicht.</span><span class="sxs-lookup"><span data-stu-id="92ad3-193">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="92ad3-194">Mehrere Methoden stehen zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="92ad3-194">You can use multiple approaches.</span></span>

<span data-ttu-id="92ad3-195">Udi Dahan hat ursprünglich (z.B. in mehreren Beiträgen wie [Domain Events – Take 2 (Domänenereignisse – Teil 2)](https://udidahan.com/2008/08/25/domain-events-take-2/)) die Verwendung einer statischen Klasse für die Verwaltung und Auslösung von Ereignissen vorgeschlagen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-195">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](https://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="92ad3-196">Dazu gehören beispielsweise eine statische Klasse mit dem Namen DomainEvents, die Domänenereignisse sofort auslöst, wenn sie aufgerufen wird, und eine Syntax wie `DomainEvents.Raise(Event myEvent)` verwendet.</span><span class="sxs-lookup"><span data-stu-id="92ad3-196">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like `DomainEvents.Raise(Event myEvent)`.</span></span> <span data-ttu-id="92ad3-197">Jimmy Bogard empfiehlt in seinem Blogbeitrag ([Strengthening your domain: Domain Events (Stärken Ihrer Domäne: Domänenereignisse)](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) einen ähnlichen Ansatz.</span><span class="sxs-lookup"><span data-stu-id="92ad3-197">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="92ad3-198">Wenn die Domänenereignisklasse statisch ist, sendet sie auch sofort an Handler.</span><span class="sxs-lookup"><span data-stu-id="92ad3-198">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="92ad3-199">Dies erschwert das Testen und Debuggen, da die Ereignishandler mit Nebenwirkungslogik unmittelbar nach der Auslösung des Ereignisses ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-199">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="92ad3-200">Wenn Sie testen und debuggen, sollten Sie sich nur auf das konzentrieren, was in den aktuellen Aggregatklassen geschieht. Achten Sie darauf, dass Sie nicht plötzlich zu anderen Ereignishandlern für Nebenwirkungen im Zusammenhang mit anderen Aggregaten oder anderer Anwendungslogik umgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-200">When you are testing and debugging, you just want to focus on what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="92ad3-201">Aus diesem Grund wurden weitere Methoden entwickelt, die im nächsten Abschnitt erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-201">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-to-raise-and-dispatch-events"></a><span data-ttu-id="92ad3-202">Verzögerter Ansatz zum Auslösen und Verteilen von Ereignissen</span><span class="sxs-lookup"><span data-stu-id="92ad3-202">The deferred approach to raise and dispatch events</span></span>

<span data-ttu-id="92ad3-203">Anstatt direkt an einen Ereignishandler für die Domäne zu senden, ist es sinnvoller, die Domänenereignisse einer Sammlung hinzuzufügen und diese Domänenereignisse anschließend *direkt vor* oder *direkt*  *nach dem* Commit der Transaktion zu senden (wie bei SaveChanges in EF).</span><span class="sxs-lookup"><span data-stu-id="92ad3-203">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="92ad3-204">(Diese Methode wurde von Jimmy Bogard in seinem Beitrag [A better domain events pattern (Ein besseres Domänenereignismuster)](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/) beschrieben.)</span><span class="sxs-lookup"><span data-stu-id="92ad3-204">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="92ad3-205">Es ist wichtig zu entscheiden, ob Sie die Domänenereignisse unmittelbar vor oder unmittelbar nach dem Commit der Transaktion senden, da sie festlegt, ob die Nebenwirkungen als Teil derselben Transaktion oder in unterschiedlichen Transaktionen eingeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-205">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="92ad3-206">Im letzterem Fall müssen Sie sich mit „Eventual Consistency“ über mehrere Aggregate befassen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-206">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="92ad3-207">Dieses Thema wird im nächsten Abschnitt behandelt.</span><span class="sxs-lookup"><span data-stu-id="92ad3-207">This topic is discussed in the next section.</span></span>

<span data-ttu-id="92ad3-208">eShopOnContainers verwendet den verzögerten Ansatz.</span><span class="sxs-lookup"><span data-stu-id="92ad3-208">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="92ad3-209">Sie fügen zunächst die Ereignisse in Ihren Entitäten in einer Sammlung oder einer Liste von Ereignissen pro Entität hinzu.</span><span class="sxs-lookup"><span data-stu-id="92ad3-209">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="92ad3-210">Diese Liste sollte Teil des Entitätsobjekts oder besser noch Teil der Basisentitätklasse sein, wie im folgenden Beispiel der Entitätsbasisklasse veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="92ad3-210">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example of the Entity base class:</span></span>

```csharp
public abstract class Entity
{
     //...
     private List<INotification> _domainEvents;
     public List<INotification> DomainEvents => _domainEvents;

     public void AddDomainEvent(INotification eventItem)
     {
         _domainEvents = _domainEvents ?? new List<INotification>();
         _domainEvents.Add(eventItem);
     }

     public void RemoveDomainEvent(INotification eventItem)
     {
         _domainEvents?.Remove(eventItem);
     }
     //... Additional code
}
```

<span data-ttu-id="92ad3-211">Wenn Sie ein Ereignis auslösen möchten, fügen Sie es einfach der Ereignissammlung aus Code auf jeder Methode der Aggregat-Stamm-Entität hinzu.</span><span class="sxs-lookup"><span data-stu-id="92ad3-211">When you want to raise an event, you just add it to the event collection from code at any method of the aggregate-root entity.</span></span>

<span data-ttu-id="92ad3-212">Der folgende Code ist Teil von [Order aggregate-root at eShopOnContainers (Aggregatstamm von Bestellung bei eShopOnContainers)](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) und enthält ein Beispiel:</span><span class="sxs-lookup"><span data-stu-id="92ad3-212">The following code, part of the [Order aggregate-root at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), shows an example:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
                                                          cardTypeId, cardNumber,
                                                          cardSecurityNumber,
                                                          cardHolderName,
                                                          cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="92ad3-213">Beachten Sie, dass die AddDomainEvent-Methode lediglich ein Ereignis der Liste hinzufügt.</span><span class="sxs-lookup"><span data-stu-id="92ad3-213">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="92ad3-214">Es wurde noch kein Ereignis gesendet und noch kein Ereignishandler aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-214">No event is dispatched yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="92ad3-215">Sie sollten die Ereignisse später senden, wenn Sie ein Commit für die Transaktion an die Datenbank ausgeführt haben.</span><span class="sxs-lookup"><span data-stu-id="92ad3-215">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="92ad3-216">Bei Verwendung von Entity Framework Core bedeutet dies in der SaveChanges-Methode Ihres EF-DbContext wie im folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="92ad3-216">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.
        await _mediator.DispatchDomainEventsAsync(this);

        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be committed
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="92ad3-217">Mit dem Code verteilen Sie die Entitätsereignisse an die entsprechenden Ereignishandler.</span><span class="sxs-lookup"><span data-stu-id="92ad3-217">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="92ad3-218">Insgesamt gesehen haben Sie das Auslösen eines Domänenereignisses (einfaches Hinzufügen zu einer Liste im Speicher) vom Versand an einen Ereignishandler abgekoppelt.</span><span class="sxs-lookup"><span data-stu-id="92ad3-218">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="92ad3-219">Darüber hinaus haben Sie abhängig von der Art des von Ihnen verwendeten Verteilers die Möglichkeit, die Ereignisse synchron oder asynchron zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-219">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="92ad3-220">Bedenken Sie, dass hier transaktionale Grenzen eine gewichtige Rolle spielen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-220">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="92ad3-221">Wenn Arbeitseinheit und Transaktion mehrere Aggregate umfassen können (wie bei Verwendung von EF Core und einer relationalen Datenbank), kann dies gut funktionieren.</span><span class="sxs-lookup"><span data-stu-id="92ad3-221">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="92ad3-222">Wenn jedoch die Transaktion keine Aggregate umfassen kann, z.B. wenn Sie eine NoSQL-Datenbank wie CosmosDB verwenden, implementieren Sie zusätzliche Schritte, um Konsistenz zu gewährleisten.</span><span class="sxs-lookup"><span data-stu-id="92ad3-222">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure CosmosDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="92ad3-223">Dies ist ein weiterer Grund, weshalb das Ignorieren der Persistenz nicht universell ist. Es richtet sich vielmehr nach dem von Ihnen verwendeten Speichersystem.</span><span class="sxs-lookup"><span data-stu-id="92ad3-223">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="92ad3-224">Einzelne Transaktion über Aggregate im Vergleich zu „Eventual Consistency“ über Aggregate</span><span class="sxs-lookup"><span data-stu-id="92ad3-224">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="92ad3-225">Die Frage, ob eine einzelne Transaktion über Aggregate ausgeführt oder „Eventual Consistency“ über diese Aggregate angenommen werden soll, ist durchaus kontrovers.</span><span class="sxs-lookup"><span data-stu-id="92ad3-225">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="92ad3-226">Viele DDD-Autoren wie Eric Evans und Vaughn Vernon befürworten die Regel: eine Transaktion = ein Aggregat und sprechen sich daher für „Eventual Consistency“ über Aggregate aus.</span><span class="sxs-lookup"><span data-stu-id="92ad3-226">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="92ad3-227">Eric Evans erklärt in seinem Buch *Domain-Driven Design(Domänengesteuertes Design)* beispielsweise Folgendes:</span><span class="sxs-lookup"><span data-stu-id="92ad3-227">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

> <span data-ttu-id="92ad3-228">Es kann nicht davon ausgegangen werden, dass jede Regel, die Aggregate umfasst, jederzeit auf dem neuesten Stand ist.</span><span class="sxs-lookup"><span data-stu-id="92ad3-228">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="92ad3-229">Durch die Ereignisverarbeitung, Batchverarbeitung oder andere Aktualisierungsmechanismen können andere Abhängigkeiten innerhalb einer bestimmten Zeit aufgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-229">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="92ad3-230">(Seite 128)</span><span class="sxs-lookup"><span data-stu-id="92ad3-230">(page 128)</span></span>

<span data-ttu-id="92ad3-231">Vaughn Vernon erklärt Folgendes in [Effective Aggregate Design. Part II: Making Aggregates Work Together (Effektive Aggregatentwicklung Teil II: Kooperation von Aggregaten)](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="92ad3-231">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

> <span data-ttu-id="92ad3-232">Wenn die Ausführung eines Befehls auf einer Aggregatinstanz erfordert, dass zusätzliche Geschäftsregeln auf einem oder mehreren Aggregaten ausgeführt werden, sollte „Eventual Consistency“ verwendet werden\[...\] Es gibt eine praktische Möglichkeit, „Eventual Consistency“ in einem DDD-Modell zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-232">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="92ad3-233">Eine Aggregatmethode veröffentlicht ein Domänenereignis, das rechtzeitig an einen oder mehrere asynchrone Abonnenten übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="92ad3-233">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="92ad3-234">Dieser Grundgedanke basiert auf differenzierten Transaktionen und nicht auf Transaktionen, die mehrere Aggregate oder Entitäten umfassen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-234">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="92ad3-235">Dabei wird davon ausgegangen, dass die Anzahl von Datenbanksperren im zweiten Fall in umfangreichen Anwendungen mit hohen Skalierbarkeitsanforderungen erheblich ist.</span><span class="sxs-lookup"><span data-stu-id="92ad3-235">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="92ad3-236">Wenn anerkannt wird, dass hochskalierbare Anwendungen keine sofortige Transaktionskonsistenz zwischen mehreren Aggregaten benötigen, erleichtert dies die Akzeptanz des Konzepts „Letztliche Konsistenz“.</span><span class="sxs-lookup"><span data-stu-id="92ad3-236">Embracing the fact that highly scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="92ad3-237">Unternehmen benötigen atomische Änderungen häufig nicht, und es ist stets Aufgabe der Domänenexperten festzustellen, ob bestimmte Vorgänge atomische Transaktionen erfordern.</span><span class="sxs-lookup"><span data-stu-id="92ad3-237">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="92ad3-238">Wenn ein Vorgang immer eine atomische Transaktion zwischen mehreren Aggregaten erfordert, könnten Sie die Frage stellen, ob das Aggregat größer sein sollte oder nicht korrekt konzipiert wurde.</span><span class="sxs-lookup"><span data-stu-id="92ad3-238">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="92ad3-239">Andere Entwickler und Architekten wie Jimmy Bogard akzeptieren, dass eine einzelne Transaktion mehrere Aggregate umfassen kann. Allerdings nur dann, wenn die zusätzlichen Aggregate mit Nebenwirkungen für den gleichen ursprünglichen Befehl verknüpft sind.</span><span class="sxs-lookup"><span data-stu-id="92ad3-239">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="92ad3-240">In [A better domain events pattern (Ein besseres Domänenmuster)](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/) erklärt Bogard beispielsweise:</span><span class="sxs-lookup"><span data-stu-id="92ad3-240">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

> <span data-ttu-id="92ad3-241">Ich möchte in der Regel, dass die Nebenwirkungen eines Domänenereignisses innerhalb der gleichen logischen Transaktion auftreten, aber nicht unbedingt im Rahmen der Auslösung des Domänenereignisses\[...\] Kurz bevor wir unsere Transaktion committen, senden wir die Ereignisse an ihre jeweiligen Handler.</span><span class="sxs-lookup"><span data-stu-id="92ad3-241">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="92ad3-242">Sie senden Domänenereignisse unmittelbar *vor* dem Ausführen eines Commits für die ursprüngliche Transaktion, falls die Nebenwirkungen dieser Ereignisse in der gleichen Transaktion eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-242">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="92ad3-243">Wenn z.B. die EF DbContext SaveChanges-Methode fehlschlägt, führt die Transaktion einen Rollback aller Änderungen durch, auch des Ergebnisses von Nebenwirkungsvorgängen, die von den zugehörigen Domänenereignishandlern implementiert wurden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-243">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="92ad3-244">Dies ist darauf zurückzuführen, dass der DbContext-Lebensdauerbereich standardmäßig als „bereichsbezogen“ definiert ist.</span><span class="sxs-lookup"><span data-stu-id="92ad3-244">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="92ad3-245">Aus diesem Grund wird das DbContext-Objekt von mehreren Repositoryobjekten, die innerhalb des gleichen Bereichs oder Objektdiagramms instanziiert sind, gemeinsam genutzt.</span><span class="sxs-lookup"><span data-stu-id="92ad3-245">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="92ad3-246">Dies stimmt mit dem HttpRequest-Bereich bei der Entwicklung von Web-API- oder MVC-Apps überein.</span><span class="sxs-lookup"><span data-stu-id="92ad3-246">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="92ad3-247">Tatsächlich können beide Ansätze (einzelne atomische Transaktion und letztliche Konsistenz) korrekt sein.</span><span class="sxs-lookup"><span data-stu-id="92ad3-247">Actually, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="92ad3-248">Ausschlaggebend sind in Wirklichkeit Ihre Domänen- oder Geschäftsanforderungen und die Informationen der Domänenexperten.</span><span class="sxs-lookup"><span data-stu-id="92ad3-248">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="92ad3-249">Ausschlaggebend ist auch, wie skalierbar der Dienst sein soll (differenziertere Transaktionen haben weniger Auswirkungen in Bezug auf die Datenbanksperren).</span><span class="sxs-lookup"><span data-stu-id="92ad3-249">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="92ad3-250">Und schließlich ist auch ausschlaggebend, wie viel Sie in Ihren Code investieren möchten, da „Eventual Consistency“ komplexeren Code voraussetzt, um mögliche aggregatübergreifende Inkonsistenzen zu erkennen,und die Implementierung von Kompensationsaktionen erfordert.</span><span class="sxs-lookup"><span data-stu-id="92ad3-250">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="92ad3-251">Berücksichtigen Sie Folgendes: Wenn Sie Änderungen am ursprünglichen Aggregat committen und später beim Verteilen der Ereignisse ein Problem auftritt und die Handler ihre Nebenwirkungen nicht committen können, sind Inkonsistenzen zwischen Aggregaten die Folge.</span><span class="sxs-lookup"><span data-stu-id="92ad3-251">Consider that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, if there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="92ad3-252">Kompensationsaktionen können zugelassen werden, indem beispielsweise die Domänenereignisse in zusätzlichen Datenbanktabellen gespeichert werden, sodass sie Bestandteil der ursprünglichen Transaktion sein können.</span><span class="sxs-lookup"><span data-stu-id="92ad3-252">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="92ad3-253">Anschließend kann ein Batchprozess Inkonsistenzen erkennen und Kompensationsaktionen ausführen, indem die Liste der Ereignisse mit dem aktuellen Status der Aggregate verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="92ad3-253">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="92ad3-254">Die Kompensationsaktionen sind Teil eines komplexen Themas, das Sie eingehend analysieren und u.a. mit dem Geschäftskunden und Domänenexperten erörtern müssen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-254">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="92ad3-255">In jedem Fall können Sie die Methode auswählen, die Sie benötigen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-255">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="92ad3-256">Der ursprüngliche verzögerte Ansatz – Auslösen des Ereignissen vor dem Committen, damit eine einzelne Transaktion verwendet wird – ist der einfachste Ansatz bei Verwendung von EF Core und einer relationalen Datenbank.</span><span class="sxs-lookup"><span data-stu-id="92ad3-256">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="92ad3-257">In vielen Geschäftsvorgängen ist dieser Ansatz einfacher zu implementieren und zu validieren.</span><span class="sxs-lookup"><span data-stu-id="92ad3-257">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="92ad3-258">Der Ansatz wird auch im Microservice für Bestellungen in eShopOnContainers verwendet.</span><span class="sxs-lookup"><span data-stu-id="92ad3-258">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="92ad3-259">Aber wie senden Sie eigentlich die Ereignisse an ihre jeweiligen Ereignishandler?</span><span class="sxs-lookup"><span data-stu-id="92ad3-259">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="92ad3-260">Worum handelt es sich beim `_mediator`-Objekt aus dem vorherigen Beispiel?</span><span class="sxs-lookup"><span data-stu-id="92ad3-260">What's the `_mediator` object you see in the previous example?</span></span> <span data-ttu-id="92ad3-261">Es steht in Verbindung mit den Verfahren und Artefakten, mit denen Sie Ereignisse und Ereignishandler einander zuordnen können.</span><span class="sxs-lookup"><span data-stu-id="92ad3-261">It has to do with the techniques and artifacts you use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="92ad3-262">Der Domänenereignisverteiler: Zuordnen von Ereignissen zu Ereignishandlern</span><span class="sxs-lookup"><span data-stu-id="92ad3-262">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="92ad3-263">Sobald Sie die Ereignisse senden oder veröffentlichen können, benötigen Sie eine Art Artefakt, das das Ereignis veröffentlicht, damit alle zugehörigen Handler es abrufen und Nebenwirkungen auf der Grundlage des Ereignisses verarbeiten können.</span><span class="sxs-lookup"><span data-stu-id="92ad3-263">Once you're able to dispatch or publish the events, you need some kind of artifact that will publish the event, so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="92ad3-264">Ein Ansatz ist ein echtes Messagingsystem oder sogar ein Ereignisbus, möglicherweise basierend auf einem Service Bus und nicht auf In-Memory-Ereignissen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-264">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="92ad3-265">Beim ersten Fall wäre das echte Messaging „zu viel“ für die Verarbeitung von Domänenereignissen, da Sie diese Ereignisse lediglich im gleichen Prozess verarbeiten müssen, d.h. in der gleichen Domäne und Anwendungsschicht.</span><span class="sxs-lookup"><span data-stu-id="92ad3-265">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="92ad3-266">Eine andere Möglichkeit, Ereignisse mehreren Ereignishandlern zuzuordnen, ist die Verwendung der Typenregistrierung in einem IoC-Container, damit Sie dynamisch ableiten können, wohin die Ereignisse gesendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-266">Another way to map events to multiple event handlers is by using types registration in an IoC container so you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="92ad3-267">Das heißt, Sie müssen wissen, welche Ereignishandler ein bestimmtes Ereignis abrufen müssen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-267">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="92ad3-268">Abbildung 7-16 zeigt einen vereinfachten Ansatz dafür.</span><span class="sxs-lookup"><span data-stu-id="92ad3-268">Figure 7-16 shows a simplified approach for this approach.</span></span>

![Diagramm, das einen Domänenereignisverteiler zeigt, der Ereignisse an die geeigneten Handler sendet.](./media/domain-events-design-implementation/domain-event-dispatcher.png)

<span data-ttu-id="92ad3-270">**Abbildung 7-16**.</span><span class="sxs-lookup"><span data-stu-id="92ad3-270">**Figure 7-16**.</span></span> <span data-ttu-id="92ad3-271">Domänenereignisverteiler mit IoC</span><span class="sxs-lookup"><span data-stu-id="92ad3-271">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="92ad3-272">Sie können alle zugrunde liegenden Strukturen und Artefakte entwickeln, die diesen Ansatz selbst umzusetzen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-272">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="92ad3-273">Allerdings können Sie auch verfügbare Bibliotheken wie [MediatR](https://github.com/jbogard/MediatR) verwenden, die im Hintergrund Ihren IoC-Container nutzt.</span><span class="sxs-lookup"><span data-stu-id="92ad3-273">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR) that uses your IoC container under the covers.</span></span> <span data-ttu-id="92ad3-274">Sie können daher direkt die vordefinierten Schnittstellen und die Veröffentlichungs-/Versandmethode des Vermittlerobjekts verwenden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-274">You can therefore directly use the predefined interfaces and the mediator object's publish/dispatch methods.</span></span>

<span data-ttu-id="92ad3-275">Im Code müssen Sie zuerst die Ereignishandlertypen im IoC-Container registrieren, was im folgenden Beispiel [eShopOnContainers Reihenfolge Microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs) gezeigt wird:</span><span class="sxs-lookup"><span data-stu-id="92ad3-275">In code, you first need to register the event handler types in your IoC container, as shown in the following example at [eShopOnContainers Ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement IAsyncNotificationHandler<>)
        // in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
                                       .GetTypeInfo().Assembly)
                                         .AsClosedTypesOf(typeof(IAsyncNotificationHandler<>));
        // Other registrations ...
    }
}
```

<span data-ttu-id="92ad3-276">Der Code identifiziert zunächst die Assembly, die die Domänenereignishandler enthält, indem die Assembly, die einen Handler enthält, gesucht wird (mit typeof(ValidateOrAddBuyerAggregateWhenXxxx). Sie können die Assembly aber auch mit jedem anderen Ereignishandler suchen).</span><span class="sxs-lookup"><span data-stu-id="92ad3-276">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="92ad3-277">Da alle Ereignishandler die IAsyncNotificationHandler-Schnittstelle implementieren, sucht der Code dann einfach diese Typen und registriert alle Ereignishandler.</span><span class="sxs-lookup"><span data-stu-id="92ad3-277">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="92ad3-278">Abonnieren von Domänenereignissen</span><span class="sxs-lookup"><span data-stu-id="92ad3-278">How to subscribe to domain events</span></span>

<span data-ttu-id="92ad3-279">Bei Verwendung von MediatR muss jeder Ereignishandler einen Ereignistyp verwenden, der für den generischen Parameter der INotificationHandler-Schnittstelle bereitgestellt wird, was Sie im folgenden Code sehen können:</span><span class="sxs-lookup"><span data-stu-id="92ad3-279">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the INotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="92ad3-280">Basierend auf der Beziehung zwischen Ereignis und Ereignishandler, die als Abonnement betrachtet werden kann, kann das MediatR-Artefakt alle Ereignishandler für jedes Ereignis erkennen und alle Ereignishandler auslösen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-280">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each one of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="92ad3-281">Behandeln von Domänenereignissen</span><span class="sxs-lookup"><span data-stu-id="92ad3-281">How to handle domain events</span></span>

<span data-ttu-id="92ad3-282">Abschließend implementiert der Ereignishandler in der Regel Anwendungsebenencode, der Infrastrukturrepositorys zum Abrufen der erforderlichen zusätzlichen Aggregate und Ausführen der Domänenlogik der Nebenwirkungen verwendet.</span><span class="sxs-lookup"><span data-stu-id="92ad3-282">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="92ad3-283">Der folgende [Code für Domänenereignishandler auf eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs) veranschaulicht ein Implementierungsbeispiel.</span><span class="sxs-lookup"><span data-stu-id="92ad3-283">The following [domain event handler code at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), shows an implementation example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
                   : INotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;

    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // ...Parameter validations...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1;
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;

        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }

        buyer.VerifyOrAddPaymentMethod(cardTypeId,
                                       $"Payment Method on {DateTime.UtcNow}",
                                       orderStartedEvent.CardNumber,
                                       orderStartedEvent.CardSecurityNumber,
                                       orderStartedEvent.CardHolderName,
                                       orderStartedEvent.CardExpiration,
                                       orderStartedEvent.Order.Id);

        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer)
                                                                      : _buyerRepository.Add(buyer);

        await _buyerRepository.UnitOfWork
                .SaveEntitiesAsync();

        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="92ad3-284">Der vorherige Code für Domänenereignishandlercode wird als Anwendungsebenencode betrachtet, da er Infrastrukturrepositorys verwendet, was im nächsten Abschnitt zur Infrastrukturpersistenzebene erläutert wird.</span><span class="sxs-lookup"><span data-stu-id="92ad3-284">The previous domain event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="92ad3-285">Ereignishandler können auch andere Infrastrukturkomponenten verwenden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-285">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="92ad3-286">Domänenereignisse können Integrationsereignisse generieren, die außerhalb der Grenzen von Microservices veröffentlicht werden sollen</span><span class="sxs-lookup"><span data-stu-id="92ad3-286">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="92ad3-287">Schließlich ist es wichtig zu erwähnen, dass Ereignisse manchmal über mehrere Microservices verteilt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-287">Finally, it's important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="92ad3-288">Diese Verteilung ist ein Integrationsereignis und kann von jedem Domänenereignishandler über einen Ereignisbus veröffentlicht werden.</span><span class="sxs-lookup"><span data-stu-id="92ad3-288">That propagation is an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="92ad3-289">Domänenereignisse – Fazit</span><span class="sxs-lookup"><span data-stu-id="92ad3-289">Conclusions on domain events</span></span>

<span data-ttu-id="92ad3-290">Verwenden Sie Domänenereignisse, um explizit Nebenwirkungen von Änderungen in Ihrer Domäne zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="92ad3-290">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="92ad3-291">Um die DDD-Terminologie zu verwenden, setzen Sie Domänenereignisse ein, um explizit Nebenwirkungen über ein oder mehrere Aggregate zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="92ad3-291">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="92ad3-292">Verwenden Sie zusätzlich für eine bessere Skalierbarkeit und weniger Auswirkungen in Datenbanksperren Eventual Consistency zwischen Aggregaten in der gleichen Domäne.</span><span class="sxs-lookup"><span data-stu-id="92ad3-292">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

<span data-ttu-id="92ad3-293">Die Referenz-App verwendet [MediatR](https://github.com/jbogard/MediatR), um Domänenereignisse innerhalb einer Transaktion synchron zwischen Aggregaten zu verteilen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-293">The reference app uses [MediatR](https://github.com/jbogard/MediatR) to propagate domain events synchronously across aggregates, within a single transaction.</span></span> <span data-ttu-id="92ad3-294">Sie können auch eine AMQP-Implementierung wie [RabbitMQ](https://www.rabbitmq.com/) oder [Azure Service Bus](/azure/service-bus-messaging/service-bus-messaging-overview) verwenden, um Domänenereignisse asynchron zu verteilen. Dies geschieht mithilfe der letztlichen Konsistenz, aber Sie müssen, wie oben erwähnt, die Notwendigkeit von Kompensationsaktionen bei Fehlern berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="92ad3-294">However, you could also use some AMQP implementation like [RabbitMQ](https://www.rabbitmq.com/) or [Azure Service Bus](/azure/service-bus-messaging/service-bus-messaging-overview) to propagate domain events asynchronously, using eventual consistency but, as mentioned above, you have to consider the need for compensatory actions in case of failures.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="92ad3-295">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="92ad3-295">Additional resources</span></span>

- <span data-ttu-id="92ad3-296">**Greg Young. What is a Domain Event? (Was ist ein Domänenereignis?)**</span><span class="sxs-lookup"><span data-stu-id="92ad3-296">**Greg Young. What is a Domain Event?**</span></span> \
  <https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf#page=25>

- <span data-ttu-id="92ad3-297">**Jan Stenberg. Domain Events and Eventual Consistency (Domänenereignisse und letztliche Konsistenz)**  </span><span class="sxs-lookup"><span data-stu-id="92ad3-297">**Jan Stenberg. Domain Events and Eventual Consistency** </span></span>\
  <https://www.infoq.com/news/2015/09/domain-events-consistency>

- <span data-ttu-id="92ad3-298">**Jimmy Bogard. A better domain events pattern (Ein verbessertes Domänenereignismuster)**  </span><span class="sxs-lookup"><span data-stu-id="92ad3-298">**Jimmy Bogard. A better domain events pattern** </span></span>\
  <https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/>

- <span data-ttu-id="92ad3-299">**Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work Together (Effektive Aggregatentwicklung Teil II: Kooperation von Aggregaten)**  </span><span class="sxs-lookup"><span data-stu-id="92ad3-299">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together** </span></span>\
  [https://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)

- <span data-ttu-id="92ad3-300">**Jimmy Bogard. Strengthening your domain: Domain Events (Stärken Ihrer Domäne: Domänenereignisse)**  </span><span class="sxs-lookup"><span data-stu-id="92ad3-300">**Jimmy Bogard. Strengthening your domain: Domain Events** </span></span>\
  <https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>

- <span data-ttu-id="92ad3-301">**Tony Truong. Domain Events Pattern Example (Beispiel für das Domänenereignismuster)**  </span><span class="sxs-lookup"><span data-stu-id="92ad3-301">**Tony Truong. Domain Events Pattern Example** </span></span>\
  <https://www.tonytruong.net/domain-events-pattern-example/>

- <span data-ttu-id="92ad3-302">**Udi Dahan. How to create fully encapsulated Domain Models (Erstellen eines vollständig gekapselten Domänenmodells)**  </span><span class="sxs-lookup"><span data-stu-id="92ad3-302">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <https://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

- <span data-ttu-id="92ad3-303">**Udi Dahan. Domain Events – Take 2 (Domänenereignisse: Teil II)**  </span><span class="sxs-lookup"><span data-stu-id="92ad3-303">**Udi Dahan. Domain Events – Take 2** </span></span>\
  <https://udidahan.com/2008/08/25/domain-events-take-2/>

- <span data-ttu-id="92ad3-304">**Udi Dahan. Domain Events – Salvation (Domänenereignisse: Nachtrag mit Verbesserungen)**  </span><span class="sxs-lookup"><span data-stu-id="92ad3-304">**Udi Dahan. Domain Events – Salvation** </span></span>\
  <https://udidahan.com/2009/06/14/domain-events-salvation/>

- <span data-ttu-id="92ad3-305">**Jan Kronquist. Don't publish Domain Events, return them! (Warum das Zurückgeben dem Veröffentlichen von Domänenereignissen vorzuziehen ist)**</span><span class="sxs-lookup"><span data-stu-id="92ad3-305">**Jan Kronquist. Don't publish Domain Events, return them!**</span></span> \
  <https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/>

- <span data-ttu-id="92ad3-306">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures (Domänenereignisse vs. Integrationsereignisse in DDD und Microservicearchitekturen)**  </span><span class="sxs-lookup"><span data-stu-id="92ad3-306">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures** </span></span>\
  <https://devblogs.microsoft.com/cesardelatorre/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/>

>[!div class="step-by-step"]
><span data-ttu-id="92ad3-307">[Zurück](client-side-validation.md)
>[Weiter](infrastructure-persistence-layer-design.md)</span><span class="sxs-lookup"><span data-stu-id="92ad3-307">[Previous](client-side-validation.md)
[Next](infrastructure-persistence-layer-design.md)</span></span>
