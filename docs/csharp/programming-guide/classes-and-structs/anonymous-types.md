---
title: Anonyme Typen – C#-Programmierhandbuch
description: Anonyme Typen in C# kapseln schreibgeschützte Eigenschaften in einem Objekt, ohne dass explizit ein Typ definiert werden muss. Der Compiler generiert einen Namen.
ms.date: 07/20/2015
helpviewer_keywords:
- anonymous types [C#]
- C# Language, anonymous types
ms.assetid: 59c9d7a4-3b0e-475e-b620-0ab86c088e9b
ms.openlocfilehash: f60c1ea4f3f029ec3b81a4197a711523ec372df9
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 09/24/2020
ms.locfileid: "91186158"
---
# <a name="anonymous-types-c-programming-guide"></a><span data-ttu-id="acf70-104">Anonyme Typen (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="acf70-104">Anonymous Types (C# Programming Guide)</span></span>

<span data-ttu-id="acf70-105">Anonyme Typen stellen eine praktische Möglichkeit dar, einen Satz schreibgeschützter Eigenschaften in einem Objekt zu kapseln, ohne zuerst explizit einen Typ definieren zu müssen.</span><span class="sxs-lookup"><span data-stu-id="acf70-105">Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.</span></span> <span data-ttu-id="acf70-106">Der Typname wird vom Compiler generiert und ist auf Quellcodeebene nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="acf70-106">The type name is generated by the compiler and is not available at the source code level.</span></span> <span data-ttu-id="acf70-107">Der Typ der einzelnen Eigenschaften wird vom Compiler abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="acf70-107">The type of each property is inferred by the compiler.</span></span>  
  
 <span data-ttu-id="acf70-108">Sie erstellen anonyme Typen mit dem [new](../../language-reference/operators/new-operator.md)-Operator und einem Objektinitialisierer.</span><span class="sxs-lookup"><span data-stu-id="acf70-108">You create anonymous types by using the [new](../../language-reference/operators/new-operator.md) operator together with an object initializer.</span></span> <span data-ttu-id="acf70-109">Informationen über Objektinitialisierer finden Sie unter[Objekt- und Auflistungsinitialisierer](./object-and-collection-initializers.md).</span><span class="sxs-lookup"><span data-stu-id="acf70-109">For more information about object initializers, see [Object and Collection Initializers](./object-and-collection-initializers.md).</span></span>  
  
 <span data-ttu-id="acf70-110">Das folgende Beispiel veranschaulicht einen anonymen Typ, der mit den beiden Eigenschaften `Amount` und `Message` initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="acf70-110">The following example shows an anonymous type that is initialized with two properties named `Amount` and `Message`.</span></span>  
  
```csharp  
var v = new { Amount = 108, Message = "Hello" };  
  
// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
```  
  
 <span data-ttu-id="acf70-111">Anonyme Typen werden normalerweise in der [select](../../language-reference/keywords/select-clause.md)-Klausel eines Abfrageausdrucks verwendet, um von jedem Objekt in der Quellsequenz eine Teilmenge der Eigenschaften zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="acf70-111">Anonymous types typically are used in the [select](../../language-reference/keywords/select-clause.md) clause of a query expression to return a subset of the properties from each object in the source sequence.</span></span> <span data-ttu-id="acf70-112">Weitere Informationen zu Abfragen finden Sie unter [LINQ in C#](../../linq/index.md).</span><span class="sxs-lookup"><span data-stu-id="acf70-112">For more information about queries, see [LINQ in C#](../../linq/index.md).</span></span>  
  
 <span data-ttu-id="acf70-113">Anonyme Typen enthalten mindestens eine schreibgeschützte Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="acf70-113">Anonymous types contain one or more public read-only properties.</span></span> <span data-ttu-id="acf70-114">Andere Arten von Klassenmembern wie Methoden oder Ereignisse sind ungültig.</span><span class="sxs-lookup"><span data-stu-id="acf70-114">No other kinds of class members, such as methods or events, are valid.</span></span> <span data-ttu-id="acf70-115">Der Ausdruck, der zum Initialisieren einer Eigenschaft verwendet wird, kann weder `null` noch eine anonyme Funktion oder ein Zeigertyp sein.</span><span class="sxs-lookup"><span data-stu-id="acf70-115">The expression that is used to initialize a property cannot be `null`, an anonymous function, or a pointer type.</span></span>  
  
 <span data-ttu-id="acf70-116">Das gängigste Szenario ist die Initialisierung eines anonymen Typs mit den Eigenschaften eines anderen Typs.</span><span class="sxs-lookup"><span data-stu-id="acf70-116">The most common scenario is to initialize an anonymous type with properties from another type.</span></span> <span data-ttu-id="acf70-117">Nehmen Sie im folgenden Beispiel an, dass eine Klasse mit dem Namen `Product` vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="acf70-117">In the following example, assume that a class exists that is named `Product`.</span></span> <span data-ttu-id="acf70-118">Die `Product`-Klasse enthält die Eigenschaften `Color` und `Price` sowie weitere Eigenschaften, die für Sie nicht relevant sind.</span><span class="sxs-lookup"><span data-stu-id="acf70-118">Class `Product` includes `Color` and `Price` properties, together with other properties that you are not interested in.</span></span> <span data-ttu-id="acf70-119">Die Variable `products` ist eine Auflistung von `Product`-Objekten.</span><span class="sxs-lookup"><span data-stu-id="acf70-119">Variable `products` is a collection of `Product` objects.</span></span> <span data-ttu-id="acf70-120">Die Deklaration eines anonymen Typs beginnt mit dem Schlüsselwort `new`.</span><span class="sxs-lookup"><span data-stu-id="acf70-120">The anonymous type declaration starts with the `new` keyword.</span></span> <span data-ttu-id="acf70-121">Die Deklaration initialisiert einen neuen Typ, der nur zwei Eigenschaften von `Product` verwendet.</span><span class="sxs-lookup"><span data-stu-id="acf70-121">The declaration initializes a new type that uses only two properties from `Product`.</span></span> <span data-ttu-id="acf70-122">Dadurch wird eine geringere Datenmenge in der Abfrage zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="acf70-122">This causes a smaller amount of data to be returned in the query.</span></span>  
  
 <span data-ttu-id="acf70-123">Wenn Sie im anonymen Typ keine Membernamen angeben, gibt der Compiler den Membern des anonymen Typs den Namen der Eigenschaft, mit der sie initialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="acf70-123">If you do not specify member names in the anonymous type, the compiler gives the anonymous type members the same name as the property being used to initialize them.</span></span> <span data-ttu-id="acf70-124">Sie müssen einen Namen für eine Eigenschaft angeben, die mit einem Ausdruck initialisiert wird, wie im vorherigen Beispiel dargestellt.</span><span class="sxs-lookup"><span data-stu-id="acf70-124">You must provide a name for a property that is being initialized with an expression, as shown in the previous example.</span></span> <span data-ttu-id="acf70-125">Im folgenden Beispiel lauten die Namen der Eigenschaften des anonymen Typs `Color` und `Price`.</span><span class="sxs-lookup"><span data-stu-id="acf70-125">In the following example, the names of the properties of the anonymous type are `Color` and `Price`.</span></span>  
  
 [!code-csharp[csRef30Features#81](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csRef30Features/CS/csref30.cs#81)]  
  
 <span data-ttu-id="acf70-126">Wenn Sie einen anonymen Typ zum Initialisieren einer Variablen verwenden, deklarieren Sie die Variable normalerweise mithilfe von [var](../../language-reference/keywords/var.md) als implizit typisierte lokale Variable.</span><span class="sxs-lookup"><span data-stu-id="acf70-126">Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using [var](../../language-reference/keywords/var.md).</span></span> <span data-ttu-id="acf70-127">Der Typname kann in der Variablendeklaration nicht angegeben werden, da nur der Compiler über Zugriff auf den zugrunde liegenden Namen des anonymen Typs verfügt.</span><span class="sxs-lookup"><span data-stu-id="acf70-127">The type name cannot be specified in the variable declaration because only the compiler has access to the underlying name of the anonymous type.</span></span> <span data-ttu-id="acf70-128">Weitere Informationen zu `var` finden Sie unter [Implizit typisierte lokale Variablen](./implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="acf70-128">For more information about `var`, see [Implicitly Typed Local Variables](./implicitly-typed-local-variables.md).</span></span>  
  
 <span data-ttu-id="acf70-129">Sie können ein Array anonym typisierter Elemente erstellen, indem Sie eine implizit typisierte lokale Variable und ein implizit typisiertes Array kombinieren, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="acf70-129">You can create an array of anonymously typed elements by combining an implicitly typed local variable and an implicitly typed array, as shown in the following example.</span></span>  
  
```csharp  
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};  
```  
  
## <a name="remarks"></a><span data-ttu-id="acf70-130">Hinweise</span><span class="sxs-lookup"><span data-stu-id="acf70-130">Remarks</span></span>  

 <span data-ttu-id="acf70-131">Anonyme Typen sind [Klassentypen](../../language-reference/keywords/class.md), die direkt vom [Objekt](../../language-reference/builtin-types/reference-types.md) abgleitet werden und in keinen anderen Typ als ein [Objekt](../../language-reference/builtin-types/reference-types.md) umgewandelt werden können.</span><span class="sxs-lookup"><span data-stu-id="acf70-131">Anonymous types are [class](../../language-reference/keywords/class.md) types that derive directly from [object](../../language-reference/builtin-types/reference-types.md), and that cannot be cast to any type except [object](../../language-reference/builtin-types/reference-types.md).</span></span> <span data-ttu-id="acf70-132">Der Compiler gibt für jeden anonymen Typ einen Namen an, Ihre Anwendung kann jedoch nicht darauf zugreifen.</span><span class="sxs-lookup"><span data-stu-id="acf70-132">The compiler provides a name for each anonymous type, although your application cannot access it.</span></span> <span data-ttu-id="acf70-133">Aus der Perspektive der Common Language Runtime unterscheidet sich ein anonymer Typ nicht von anderen Verweistypen.</span><span class="sxs-lookup"><span data-stu-id="acf70-133">From the perspective of the common language runtime, an anonymous type is no different from any other reference type.</span></span>  
  
 <span data-ttu-id="acf70-134">Wenn zwei oder mehr anonyme Objektinitialisierer in einer Assembly eine Sequenz von Eigenschaften angeben, die die gleiche Reihenfolge und die gleichen Namen und Typen aufweisen, behandelt der Compiler die Objekte als Instanzen desselben Typs.</span><span class="sxs-lookup"><span data-stu-id="acf70-134">If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type.</span></span> <span data-ttu-id="acf70-135">Sie erhalten die gleichen vom Compiler generierten Typinformationen.</span><span class="sxs-lookup"><span data-stu-id="acf70-135">They share the same compiler-generated type information.</span></span>  
  
 <span data-ttu-id="acf70-136">Sie können ein Feld, eine Eigenschaft, ein Ereignis oder den Rückgabetyp einer Methode nicht mit einem anonymen Typ deklarieren.</span><span class="sxs-lookup"><span data-stu-id="acf70-136">You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type.</span></span> <span data-ttu-id="acf70-137">Auch können Sie einen formalen Parameter einer Methode, einer Eigenschaft, eines Konstruktors oder eines Indexers nicht als anonymen Typ deklarieren.</span><span class="sxs-lookup"><span data-stu-id="acf70-137">Similarly, you cannot declare a formal parameter of a method, property, constructor, or indexer as having an anonymous type.</span></span> <span data-ttu-id="acf70-138">Um einen anonymen Typ oder eine Auflistung mit anonymen Typen als Argument einer Methode zu übergeben, können Sie den Parameter als Typobjekt deklarieren.</span><span class="sxs-lookup"><span data-stu-id="acf70-138">To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare the parameter as type object.</span></span> <span data-ttu-id="acf70-139">Dadurch wird jedoch der Zweck der starken Typisierung vereitelt.</span><span class="sxs-lookup"><span data-stu-id="acf70-139">However, doing this defeats the purpose of strong typing.</span></span> <span data-ttu-id="acf70-140">Wenn Sie Abfrageergebnisse speichern oder außerhalb der Methodengrenze übergeben müssen, könnten Sie statt eines anonymen Typs eine Struktur oder Klasse mit einem gewöhnlichen Namen verwenden.</span><span class="sxs-lookup"><span data-stu-id="acf70-140">If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.</span></span>  
  
 <span data-ttu-id="acf70-141">Da die Methoden <xref:System.Object.Equals%2A> und <xref:System.Object.GetHashCode%2A> von anonymen Typen anhand der Methoden `Equals` und `GetHashCode` der Eigenschaften definiert werden, sind zwei Instanzen eines anonymen Typs nur gleich, wenn alle Eigenschaften gleich sind.</span><span class="sxs-lookup"><span data-stu-id="acf70-141">Because the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods on anonymous types are defined in terms of the `Equals` and `GetHashCode` methods of the properties, two instances of the same anonymous type are equal only if all their properties are equal.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="acf70-142">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="acf70-142">See also</span></span>

- [<span data-ttu-id="acf70-143">C#-Programmierhandbuch</span><span class="sxs-lookup"><span data-stu-id="acf70-143">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="acf70-144">Objekt- und Auflistungsinitialisierer</span><span class="sxs-lookup"><span data-stu-id="acf70-144">Object and Collection Initializers</span></span>](./object-and-collection-initializers.md)
- [<span data-ttu-id="acf70-145">Erste Schritte mit LINQ in C#</span><span class="sxs-lookup"><span data-stu-id="acf70-145">Getting Started with LINQ in C#</span></span>](../concepts/linq/index.md)
- [<span data-ttu-id="acf70-146">LINQ in C#</span><span class="sxs-lookup"><span data-stu-id="acf70-146">LINQ in C#</span></span>](../../linq/index.md)
