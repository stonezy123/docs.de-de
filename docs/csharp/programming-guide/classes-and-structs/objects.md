---
title: Objekte – C#-Programmierhandbuch
description: C# verwendet eine Klassen- oder Strukturdefinition, um Objekttypen zu definieren. In einer objektorientierten Programmiersprache wie C# besteht ein Programm aus Objekten, die dynamisch interagieren.
ms.date: 07/20/2015
helpviewer_keywords:
- objects [C#], about objects
- variables [C#]
ms.assetid: af4a5230-fbf3-4eea-95e1-8b883c2f845c
ms.openlocfilehash: 61d79f5647fa05edade9aef90653544b08c20c83
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 09/24/2020
ms.locfileid: "91181829"
---
# <a name="objects-c-programming-guide"></a><span data-ttu-id="b2c0a-104">Objekte (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="b2c0a-104">Objects (C# Programming Guide)</span></span>

<span data-ttu-id="b2c0a-105">Die Definition einer Klasse oder Struktur ist mit einem Entwurf vergleichbar, der angibt, was der Typ machen kann.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-105">A class or struct definition is like a blueprint that specifies what the type can do.</span></span> <span data-ttu-id="b2c0a-106">Ein Objekt ist im Grunde ein Speicherblock, der nach Plan zugewiesen und konfiguriert wurde.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-106">An object is basically a block of memory that has been allocated and configured according to the blueprint.</span></span> <span data-ttu-id="b2c0a-107">Ein Programm kann viele Objekte der selben Klasse erstellen.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-107">A program may create many objects of the same class.</span></span> <span data-ttu-id="b2c0a-108">Objekte werden auch Instanzen genannt, und sie können entweder in einer benannten Variable, einem Array oder in einer Auflistung gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-108">Objects are also called instances, and they can be stored in either a named variable or in an array or collection.</span></span> <span data-ttu-id="b2c0a-109">Der Client-Code ist der Code, der diese Variablen verwendet, um die Methoden aufzurufen und um auf die öffentlichen Eigenschaften des Objekts zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-109">Client code is the code that uses these variables to call the methods and access the public properties of the object.</span></span> <span data-ttu-id="b2c0a-110">In einer objektorientierten Programmiersprache wie C# besteht ein typisches Programm aus mehreren Objekten, die dynamisch interagieren.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-110">In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b2c0a-111">Statische Typen verhalten sich anders, als die hier beschriebenen.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-111">Static types behave differently than what is described here.</span></span> <span data-ttu-id="b2c0a-112">Weitere Informationen finden Sie unter [Statische Klassen und statische Klassenmember](./static-classes-and-static-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="b2c0a-112">For more information, see [Static Classes and Static Class Members](./static-classes-and-static-class-members.md).</span></span>
  
## <a name="struct-instances-vs-class-instances"></a><span data-ttu-id="b2c0a-113">Strukturinstanzen im Vergleich zu Klasseninstanzen</span><span class="sxs-lookup"><span data-stu-id="b2c0a-113">Struct Instances vs. Class Instances</span></span>  

 <span data-ttu-id="b2c0a-114">Da Klassen Verweistypen sind, enthält eine Variable eines Klassenobjekts einen Verweis auf die Adresse des Objekts auf dem verwalteten Heap.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-114">Because classes are reference types, a variable of a class object holds a reference to the address of the object on the managed heap.</span></span> <span data-ttu-id="b2c0a-115">Wenn dem ersten Objekt ein zweites Objekt desselben Typs zugewiesen wird, verweisen beide Variablen auf das Objekt in dieser Adresse.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-115">If a second object of the same type is assigned to the first object, then both variables refer to the object at that address.</span></span> <span data-ttu-id="b2c0a-116">Dieser Punkt wird in diesem Thema an späterer Stelle ausführlicher behandelt.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-116">This point is discussed in more detail later in this topic.</span></span>  
  
 <span data-ttu-id="b2c0a-117">Instanzen von Klassen werden mit dem [new-Operator](../../language-reference/operators/new-operator.md) erstellt.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-117">Instances of classes are created by using the [new operator](../../language-reference/operators/new-operator.md).</span></span> <span data-ttu-id="b2c0a-118">Im folgenden Beispiel ist `Person` der Typ und `person1` und `person 2` sind Instanzen oder Objekte des Typs.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-118">In the following example, `Person` is the type and `person1` and `person 2` are instances, or objects, of that type.</span></span>  
  
 [!code-csharp[csProgGuideStatements#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#30)]  
  
 <span data-ttu-id="b2c0a-119">Da Strukturen Werttypen sind, enthält eine Variable eines Strukturobjekts eine Kopie des gesamten Objekts.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-119">Because structs are value types, a variable of a struct object holds a copy of the entire object.</span></span> <span data-ttu-id="b2c0a-120">Instanzen von Strukturen können auch mithilfe des `new`-Operators erstellt werden; dies ist jedoch nicht erforderlich, wie im folgenden Beispiel gezeigt wird:</span><span class="sxs-lookup"><span data-stu-id="b2c0a-120">Instances of structs can also be created by using the `new` operator, but this is not required, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#31)]  
  
 <span data-ttu-id="b2c0a-121">Der Speicher für `p1` und `p2` ist dem Stapel des Threads zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-121">The memory for both `p1` and `p2` is allocated on the thread stack.</span></span> <span data-ttu-id="b2c0a-122">Der Speicher wird zusammen mit dem Typ oder der Methode freigegeben, in dem bzw. in der er deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-122">That memory is reclaimed along with the type or method in which it is declared.</span></span> <span data-ttu-id="b2c0a-123">Dies ist ein Grund, weshalb Strukturen bei Zuweisung kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-123">This is one reason why structs are copied on assignment.</span></span> <span data-ttu-id="b2c0a-124">Im Gegensatz dazu wird der Speicher, der für eine Klasseninstanz zugeordnet ist, automatisch von der Common Language Runtime freigegeben (von Garbage Collection bereinigt), wenn alle Verweise auf das Objekt außerhalb des Gültigkeitsbereichs liegen.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-124">By contrast, the memory that is allocated for a class instance is automatically reclaimed (garbage collected) by the common language runtime when all references to the object have gone out of scope.</span></span> <span data-ttu-id="b2c0a-125">Es ist nicht möglich, ein Klassenobjekt deterministisch wie in C++ zu zerstören.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-125">It is not possible to deterministically destroy a class object like you can in C++.</span></span> <span data-ttu-id="b2c0a-126">Weitere Informationen zur Garbage Collection in .NET finden Sie unter [Garbage Collection](../../../standard/garbage-collection/index.md).</span><span class="sxs-lookup"><span data-stu-id="b2c0a-126">For more information about garbage collection in .NET, see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b2c0a-127">Die Belegung und Freigabe von Arbeitsspeicher auf dem verwalteten Heap ist in der Common Language Runtime stark optimiert.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-127">The allocation and deallocation of memory on the managed heap is highly optimized in the common language runtime.</span></span> <span data-ttu-id="b2c0a-128">In den meisten Fällen besteht kein wesentlicher Unterschied zwischen den Leistungskosten beim Zuweisen einer Klasseninstanz auf dem Heap im Vergleich zum Zuweisen einer Strukturinstanz im Stapel.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-128">In most cases there is no significant difference in the performance cost of allocating a class instance on the heap versus allocating a struct instance on the stack.</span></span>
  
## <a name="object-identity-vs-value-equality"></a><span data-ttu-id="b2c0a-129">Objektidentität im Vergleich zur Wertgleichheit</span><span class="sxs-lookup"><span data-stu-id="b2c0a-129">Object Identity vs. Value Equality</span></span>  

 <span data-ttu-id="b2c0a-130">Wenn Sie zwei Objekte auf Gleichheit vergleichen, müssen Sie zuerst unterscheiden, ob Sie wissen möchten, ob die zwei Variablen das gleiche Objekt im Speicher darstellen, oder ob die Werte von einem oder mehreren Feldern gleich sind.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-130">When you compare two objects for equality, you must first distinguish whether you want to know whether the two variables represent the same object in memory, or whether the values of one or more of their fields are equivalent.</span></span> <span data-ttu-id="b2c0a-131">Wenn Sie planen, Werte zu vergleichen, müssen Sie berücksichtigen, ob die Objekte Instanzen von Werttypen (Strukturen) oder Referenztypen (Klassen, Delegate, Arrays) sind.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-131">If you are intending to compare values, you must consider whether the objects are instances of value types (structs) or reference types (classes, delegates, arrays).</span></span>  
  
- <span data-ttu-id="b2c0a-132">Verwenden Sie die statische Methode <xref:System.Object.Equals%2A>, um zu bestimmen, ob zwei Klasseninstanzen auf den gleichen Speicherort im Arbeitsspeicher verweisen (d.h., sie haben die gleiche *Identität*).</span><span class="sxs-lookup"><span data-stu-id="b2c0a-132">To determine whether two class instances refer to the same location in memory (which means that they have the same *identity*), use the static <xref:System.Object.Equals%2A> method.</span></span> <span data-ttu-id="b2c0a-133">(<xref:System.Object?displayProperty=nameWithType> ist die implizite Basisklasse für alle Wert- und Referenztypen, einschließlich benutzerdefinierter Strukturen und Klassen.)</span><span class="sxs-lookup"><span data-stu-id="b2c0a-133">(<xref:System.Object?displayProperty=nameWithType> is the implicit base class for all value types and reference types, including user-defined structs and classes.)</span></span>  
  
- <span data-ttu-id="b2c0a-134">Verwenden Sie die Methode <xref:System.ValueType.Equals%2A?displayProperty=nameWithType>, um zu bestimmen, ob die Instanzfelder in zwei Strukturinstanzen die gleichen Werte haben.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-134">To determine whether the instance fields in two struct instances have the same values, use the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b2c0a-135">Da alle Strukturen implizit von <xref:System.ValueType?displayProperty=nameWithType> erben, rufen Sie die Methode direkt an Ihrem Objekt auf, wie im folgenden Beispiel gezeigt wird:</span><span class="sxs-lookup"><span data-stu-id="b2c0a-135">Because all structs implicitly inherit from <xref:System.ValueType?displayProperty=nameWithType>, you call the method directly on your object as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#32)]  
  
 <span data-ttu-id="b2c0a-136">Die Implementierung <xref:System.ValueType?displayProperty=nameWithType> von `Equals` verwendet Reflektion, da sie bestimmen muss, was die Felder in jeder Struktur sind.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-136">The <xref:System.ValueType?displayProperty=nameWithType> implementation of `Equals` uses reflection because it must be able to determine what the fields are in any struct.</span></span> <span data-ttu-id="b2c0a-137">Wenn Sie eigene Strukturen erstellen, überschreiben Sie die Methode `Equals`, um einen effizienten Gleichheitsalgorithmus bereitzustellen, der spezifisch für Ihren Typ ist.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-137">When creating your own structs, override the `Equals` method to provide an efficient equality algorithm that is specific to your type.</span></span>  
  
- <span data-ttu-id="b2c0a-138">Sie können möglicherweise die Methode <xref:System.Object.Equals%2A> oder den [==-Operator](../../language-reference/operators/equality-operators.md#equality-operator-) verwenden, um zu bestimmen, ob die Werte des Felds in zwei Klasseninstanzen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-138">To determine whether the values of the fields in two class instances are equal, you might be able to use the <xref:System.Object.Equals%2A> method or the [== operator](../../language-reference/operators/equality-operators.md#equality-operator-).</span></span> <span data-ttu-id="b2c0a-139">Verwenden Sie sie jedoch nur, wenn die Klasse die Werte überschrieben oder überladen hat, um eine benutzerdefinierte Definition von „Gleichheit“ für Objekte dieses Typs bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-139">However, only use them if the class has overridden or overloaded them to provide a custom definition of what "equality" means for objects of that type.</span></span> <span data-ttu-id="b2c0a-140">Die Klasse kann auch die Schnittstelle <xref:System.IEquatable%601> oder die Schnittstelle <xref:System.Collections.Generic.IEqualityComparer%601> implementieren.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-140">The class might also implement the <xref:System.IEquatable%601> interface or the <xref:System.Collections.Generic.IEqualityComparer%601> interface.</span></span> <span data-ttu-id="b2c0a-141">Beide Schnittstellen bieten Methoden, die zum Testen der Wertgleichheit verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-141">Both interfaces provide methods that can be used to test value equality.</span></span> <span data-ttu-id="b2c0a-142">Wenn Sie Ihre eigenen Klassen entwickeln, die `Equals` überschreiben, achten Sie darauf, die Richtlinien zu befolgen, die in [Vorgehensweise: Definieren von Wertgleichheit für einen Typ](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md) und <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> aufgeführt sind.</span><span class="sxs-lookup"><span data-stu-id="b2c0a-142">When designing your own classes that override `Equals`, make sure to follow the guidelines stated in [How to define value equality for a type](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md) and <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span>
  
## <a name="related-sections"></a><span data-ttu-id="b2c0a-143">Verwandte Abschnitte</span><span class="sxs-lookup"><span data-stu-id="b2c0a-143">Related Sections</span></span>  

 <span data-ttu-id="b2c0a-144">Weitere Informationen finden Sie unter:</span><span class="sxs-lookup"><span data-stu-id="b2c0a-144">For more information:</span></span>  
  
- [<span data-ttu-id="b2c0a-145">Klassen</span><span class="sxs-lookup"><span data-stu-id="b2c0a-145">Classes</span></span>](./classes.md)  
  
- [<span data-ttu-id="b2c0a-146">Konstruktoren</span><span class="sxs-lookup"><span data-stu-id="b2c0a-146">Constructors</span></span>](./constructors.md)  
  
- [<span data-ttu-id="b2c0a-147">Finalizer</span><span class="sxs-lookup"><span data-stu-id="b2c0a-147">Finalizers</span></span>](./destructors.md)  
  
- [<span data-ttu-id="b2c0a-148">Ereignisse</span><span class="sxs-lookup"><span data-stu-id="b2c0a-148">Events</span></span>](../events/index.md)  
  
## <a name="see-also"></a><span data-ttu-id="b2c0a-149">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="b2c0a-149">See also</span></span>

- [<span data-ttu-id="b2c0a-150">C#-Programmierhandbuch</span><span class="sxs-lookup"><span data-stu-id="b2c0a-150">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="b2c0a-151">object</span><span class="sxs-lookup"><span data-stu-id="b2c0a-151">object</span></span>](../../language-reference/builtin-types/reference-types.md)
- [<span data-ttu-id="b2c0a-152">Vererbung</span><span class="sxs-lookup"><span data-stu-id="b2c0a-152">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="b2c0a-153">class</span><span class="sxs-lookup"><span data-stu-id="b2c0a-153">class</span></span>](../../language-reference/keywords/class.md)
- [<span data-ttu-id="b2c0a-154">Strukturtypen</span><span class="sxs-lookup"><span data-stu-id="b2c0a-154">Structure types</span></span>](../../language-reference/builtin-types/struct.md)
- [<span data-ttu-id="b2c0a-155">new-Operator</span><span class="sxs-lookup"><span data-stu-id="b2c0a-155">new Operator</span></span>](../../language-reference/operators/new-operator.md)
- [<span data-ttu-id="b2c0a-156">Allgemeines Typsystem</span><span class="sxs-lookup"><span data-stu-id="b2c0a-156">Common Type System</span></span>](../../../standard/base-types/common-type-system.md)
