---
title: 'Vorgehensweise: Durchlaufen einer Verzeichnisstruktur (C#-Programmierleitfaden)'
description: Erfahren Sie, wie Sie eine Verzeichnisstruktur durchlaufen. Greifen Sie auf jede Datei in jedem geschachtelten Unterverzeichnis unterhalb eines angegebenen Stammordners zu.
ms.date: 07/20/2015
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
ms.openlocfilehash: 9d927e8517ddbdb1c5a9a8aa8ca3c321bf7e8d9c
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 09/24/2020
ms.locfileid: "91178540"
---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a><span data-ttu-id="5c9b9-104">Vorgehensweise: Durchlaufen einer Verzeichnisstruktur (C#-Programmierleitfaden)</span><span class="sxs-lookup"><span data-stu-id="5c9b9-104">How to iterate through a directory tree (C# Programming Guide)</span></span>

<span data-ttu-id="5c9b9-105">Der Ausdruck „Durchlaufen einer Verzeichnisstruktur“ bedeutet, dass auf jede Datei in jedem verschachtelten Unterverzeichnis in einem angegebenen Stammordner in einer beliebigen Tiefe zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-105">The phrase "iterate a directory tree" means to access each file in each nested subdirectory under a specified root folder, to any depth.</span></span> <span data-ttu-id="5c9b9-106">Sie müssen nicht unbedingt jede Datei öffnen.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-106">You do not necessarily have to open each file.</span></span> <span data-ttu-id="5c9b9-107">Sie können einfach den Namen der Datei oder dem Unterverzeichnis als `string` abrufen, oder Sie können zusätzliche Informationen eines <xref:System.IO.FileInfo?displayProperty=nameWithType> oder <xref:System.IO.DirectoryInfo?displayProperty=nameWithType>-Objekts abrufen.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-107">You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5c9b9-108">In Windows sind die Begriffe „Verzeichnis“ und „Ordner“ austauschbar.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-108">In Windows, the terms "directory" and "folder" are used interchangeably.</span></span> <span data-ttu-id="5c9b9-109">Die meisten Dokumentationen und der Text der Benutzeroberfläche verwenden den Begriff „Ordner“, aber die .NET-Klassenbibliotheken verwenden den Begriff „Verzeichnis“.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-109">Most documentation and user interface text uses the term "folder," but .NET class libraries use the term "directory."</span></span>  
  
 <span data-ttu-id="5c9b9-110">Im einfachsten Fall, in dem Sie ganz sicher sind, dass Sie über die Zugriffsberechtigungen für alle Verzeichnisse in einem angegebenen Stamm verfügen, können Sie das `System.IO.SearchOption.AllDirectories`-Flag verwenden.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-110">In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag.</span></span> <span data-ttu-id="5c9b9-111">Dieses Flag gibt alle geschachtelten Unterverzeichnisse zurück, die mit dem angegebenen Muster übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-111">This flag returns all the nested subdirectories that match the specified pattern.</span></span> <span data-ttu-id="5c9b9-112">Im folgenden Beispiel wird die Verwendung dieses Flags veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-112">The following example shows how to use this flag.</span></span>  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 <span data-ttu-id="5c9b9-113">Der Schwachpunkt bei diesem Ansatz ist, dass die Methode fehlschlägt und keine Verzeichnisse zurückgibt, wenn eines der Unterverzeichnisse im angegebenen Stamm eine <xref:System.IO.DirectoryNotFoundException> oder <xref:System.UnauthorizedAccessException> bewirkt.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-113">The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories.</span></span> <span data-ttu-id="5c9b9-114">Dasselbe gilt bei Verwendung der <xref:System.IO.DirectoryInfo.GetFiles%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-114">The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method.</span></span> <span data-ttu-id="5c9b9-115">Wenn Sie diese Ausnahmen für bestimmte Unterverzeichnisse behandeln müssen, müssen Sie die Verzeichnisstruktur manuell durchlaufen, wie in den folgenden Beispielen gezeigt.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-115">If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.</span></span>  
  
 <span data-ttu-id="5c9b9-116">Wenn Sie eine Verzeichnisstruktur manuell durchlaufen, können Sie zuerst die Unterverzeichnisse (*Durchlauf vor der Sortierung*) oder die Dateien (*Durchlauf nach der Sortierung*) behandeln.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-116">When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*).</span></span> <span data-ttu-id="5c9b9-117">Wenn Sie einen Durchlauf vor der Sortierung ausführen, durchlaufen Sie die gesamte Struktur unter dem aktuellen Ordner, bevor Sie die Dateien durchlaufen, die sich direkt in diesem Ordner befinden.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-117">If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.</span></span> <span data-ttu-id="5c9b9-118">In den Beispielen weiter unten in diesem Dokument wird ein Durchlauf nach der Sortierung ausgeführt, aber Sie können die Beispiele problemlos abändern, um einen Durchlauf vor der Sortierung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-118">The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.</span></span>  
  
 <span data-ttu-id="5c9b9-119">Eine andere Option ist, entweder Rekursion oder einen stapelbasierten Durchlauf zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-119">Another option is whether to use recursion or a stack-based traversal.</span></span> <span data-ttu-id="5c9b9-120">In den Beispielen weiter unten in diesem Dokument werden beide Ansätze gezeigt.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-120">The examples later in this document show both approaches.</span></span>  
  
 <span data-ttu-id="5c9b9-121">Wenn Sie mehrere Vorgänge für Dateien und Ordner ausführen müssen, können Sie diese Beispiele modularisieren, indem Sie den Vorgang in separate Funktionen umgestalten, die Sie mit einem einzelnen Delegaten aufrufen können.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-121">If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5c9b9-122">NTFS-Dateisysteme können *Analysepunkte* in Form von *Verknüpfungspunkten*, *symbolischen Verknüpfungen* und *festen Links* enthalten.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-122">NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*.</span></span> <span data-ttu-id="5c9b9-123">.NET wie z. B. <xref:System.IO.DirectoryInfo.GetFiles%2A> und <xref:System.IO.DirectoryInfo.GetDirectories%2A> geben keine Unterverzeichnisse unter einem Analysepunkt zurück.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-123">.NET methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point.</span></span> <span data-ttu-id="5c9b9-124">Dieses Verhalten schützt vor dem Risiko einer Endlosschleife, wenn zwei Analysepunkte aufeinander verweisen.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-124">This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.</span></span> <span data-ttu-id="5c9b9-125">Im Allgemeinen sollten Sie bei Analysepunkten äußerst vorsichtig sein, um sicherzustellen, dass Sie nicht versehentlich Dateien ändern oder löschen.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-125">In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.</span></span> <span data-ttu-id="5c9b9-126">Wenn Sie genaue Kontrolle über Analysepunkte benötigen, verwenden Sie einen Plattformaufruf oder nativen Code, um die entsprechenden Win32-Dateisystemmethoden direkt aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-126">If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="5c9b9-127">Beispiel</span><span class="sxs-lookup"><span data-stu-id="5c9b9-127">Example</span></span>  

 <span data-ttu-id="5c9b9-128">Das folgende Beispiel zeigt, wie Sie eine Verzeichnisstruktur mit Rekursion direkt durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-128">The following example shows how to walk a directory tree by using recursion.</span></span> <span data-ttu-id="5c9b9-129">Der rekursive Ansatz ist elegant, kann aber eine Stapelüberlaufausnahme verursachen, wenn die Verzeichnisstruktur groß und tief verschachtelt ist.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-129">The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.</span></span>  
  
 <span data-ttu-id="5c9b9-130">Die besonderen Ausnahmen, die verarbeitet werden, und die besonderen Aktionen, die für jede Datei und jeden Ordner ausgeführt werden, werden nur als Beispiele angegeben.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-130">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="5c9b9-131">Sie sollten diesen Code für Ihre speziellen Anforderungen ändern.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-131">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="5c9b9-132">Weitere Informationen finden Sie in den Kommentaren im Code.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-132">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#1)]  
  
## <a name="example"></a><span data-ttu-id="5c9b9-133">Beispiel</span><span class="sxs-lookup"><span data-stu-id="5c9b9-133">Example</span></span>  

 <span data-ttu-id="5c9b9-134">Im folgenden Beispiel wird gezeigt, wie Sie Dateien und Ordner in einer Verzeichnisstruktur ohne Rekursion durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-134">The following example shows how to iterate through files and folders in a directory tree without using recursion.</span></span> <span data-ttu-id="5c9b9-135">Diese Technik verwendet den generischen <xref:System.Collections.Generic.Stack%601>-Auflistungstyp, bei dem es sich um einen LIFO-Stapel handelt.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-135">This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.</span></span>  
  
 <span data-ttu-id="5c9b9-136">Die besonderen Ausnahmen, die verarbeitet werden, und die besonderen Aktionen, die für jede Datei und jeden Ordner ausgeführt werden, werden nur als Beispiele angegeben.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-136">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="5c9b9-137">Sie sollten diesen Code für Ihre speziellen Anforderungen ändern.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-137">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="5c9b9-138">Weitere Informationen finden Sie in den Kommentaren im Code.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-138">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#2)]  
  
 <span data-ttu-id="5c9b9-139">Es ist im Allgemeinen zu zeitaufwändig, bei allen Ordnern zu testen, ob die Anwendung über die Berechtigung zum Öffnen verfügt.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-139">It is generally too time-consuming to test every folder to determine whether your application has permission to open it.</span></span> <span data-ttu-id="5c9b9-140">Im Codebeispiel wird daher nur dieser Teil der Operation in einen `try/catch`-Block eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-140">Therefore, the code example just encloses that part of the operation in a `try/catch` block.</span></span> <span data-ttu-id="5c9b9-141">Sie können den `catch`-Block ändern, sodass Sie bei verweigertem Zugriff auf einen Ordner versuchen, Ihre Berechtigungen zu erhöhen, und dann erneut darauf zugreifen.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-141">You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.</span></span> <span data-ttu-id="5c9b9-142">In der Regel sollten Sie nur die Ausnahmen abfangen, die Sie behandeln können, ohne Ihre Anwendung in einem unbekannten Status zu lassen.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-142">As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.</span></span>  
  
 <span data-ttu-id="5c9b9-143">Wenn Sie den Inhalt einer Verzeichnisstruktur entweder im Arbeitsspeicher oder auf dem Datenträger speichern müssen, speichern Sie am besten nur die <xref:System.IO.FileSystemInfo.FullName%2A>-Eigenschaft (vom Typ `string`) für jede Datei.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-143">If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file.</span></span> <span data-ttu-id="5c9b9-144">Anschließend können Sie diese Zeichenfolge nach Bedarf zum Erstellen eines neuen <xref:System.IO.FileInfo>- oder <xref:System.IO.DirectoryInfo>-Objekts verwenden, oder eine beliebige Datei öffnen, für die zusätzliche Verarbeitung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-144">You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="5c9b9-145">Stabile Programmierung</span><span class="sxs-lookup"><span data-stu-id="5c9b9-145">Robust Programming</span></span>  

 <span data-ttu-id="5c9b9-146">Bei stabilem Dateiiterationscode müssen viele komplexe Zusammenhänge des Dateisystems berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="5c9b9-146">Robust file iteration code must take into account many complexities of the file system.</span></span> <span data-ttu-id="5c9b9-147">Weitere Informationen zum Windows-Dateisystem finden Sie in der [Übersicht zu NTFS](/windows-server/storage/file-server/ntfs-overview).</span><span class="sxs-lookup"><span data-stu-id="5c9b9-147">For more information on the Windows file system, see [NTFS overview](/windows-server/storage/file-server/ntfs-overview).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5c9b9-148">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="5c9b9-148">See also</span></span>

- <xref:System.IO>
- [<span data-ttu-id="5c9b9-149">LINQ und Dateiverzeichnisse</span><span class="sxs-lookup"><span data-stu-id="5c9b9-149">LINQ and File Directories</span></span>](../concepts/linq/linq-and-file-directories.md)
- [<span data-ttu-id="5c9b9-150">Das Dateisystem und die Registrierung (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="5c9b9-150">File System and the Registry (C# Programming Guide)</span></span>](./index.md)
