---
title: Vererbung in C#
description: Lernen Sie die Verwendung der Vererbung in C#-Bibliotheken und -Anwendungen.
ms.date: 07/05/2018
ms.technology: csharp-fundamentals
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: b0d6a4a3db4d6606375cc3364ee7abc3029f1d9b
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 09/24/2020
ms.locfileid: "91190461"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="94ef2-103">Vererbung in C# und .NET</span><span class="sxs-lookup"><span data-stu-id="94ef2-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="94ef2-104">Dieses Tutorial macht Sie mit der Vererbung in C# vertraut.</span><span class="sxs-lookup"><span data-stu-id="94ef2-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="94ef2-105">Vererbung ist eine Funktion der objektorientierten Programmiersprachen, die Ihnen ermöglicht, eine Basisklasse zu definieren, die eine bestimmte Funktionalität bietet (Daten und Verhalten), und abgeleitete Klassen zu definieren, die diese Funktionalität entweder übernehmen oder außer Kraft setzen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="94ef2-106">Voraussetzungen</span><span class="sxs-lookup"><span data-stu-id="94ef2-106">Prerequisites</span></span>

<span data-ttu-id="94ef2-107">In diesem Tutorial wird vorausgesetzt, dass Sie das .NET Core SDK installiert haben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-107">This tutorial assumes that you've installed the .NET Core SDK.</span></span> <span data-ttu-id="94ef2-108">Sie können dieses auf der Seite [.NET Core-Downloads](https://dotnet.microsoft.com/download) herunterladen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-108">Visit the [.NET Core Downloads](https://dotnet.microsoft.com/download) page to download it.</span></span> <span data-ttu-id="94ef2-109">Sie benötigen auch einen Code-Editor.</span><span class="sxs-lookup"><span data-stu-id="94ef2-109">You also need a code editor.</span></span> <span data-ttu-id="94ef2-110">In diesem Tutorial wird [Visual Studio Code](https://code.visualstudio.com) verwendet, obwohl Sie einen Code-Editor Ihrer Wahl verwenden können.</span><span class="sxs-lookup"><span data-stu-id="94ef2-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="94ef2-111">Ausführen der Beispiele</span><span class="sxs-lookup"><span data-stu-id="94ef2-111">Running the examples</span></span>

<span data-ttu-id="94ef2-112">Verwenden Sie zum Erstellen und Ausführen der Beispiele in diesem Tutorial das Befehlszeilenhilfsprogramm [dotnet](../../core/tools/dotnet.md).</span><span class="sxs-lookup"><span data-stu-id="94ef2-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="94ef2-113">Gehen Sie für jedes Beispiel wie folgt vor:</span><span class="sxs-lookup"><span data-stu-id="94ef2-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="94ef2-114">Erstellen Sie ein Verzeichnis zum Speichern des Beispiels.</span><span class="sxs-lookup"><span data-stu-id="94ef2-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="94ef2-115">Geben Sie den Befehl [dotnet new console](../../core/tools/dotnet-new.md) in einer Befehlszeile ein, um ein neues .NET Core-Projekt zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="94ef2-116">Kopieren Sie den Code aus dem Beispiel, und fügen Sie ihn in den Code-Editor ein.</span><span class="sxs-lookup"><span data-stu-id="94ef2-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="94ef2-117">Geben Sie den Befehl [dotnet restore](../../core/tools/dotnet-restore.md) in der Befehlszeile ein, um die Abhängigkeiten des Projekts zu laden oder wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

   [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="94ef2-118">Geben Sie den Befehl [dotnet run](../../core/tools/dotnet-run.md) zum Kompilieren und Ausführen des Beispiels ein.</span><span class="sxs-lookup"><span data-stu-id="94ef2-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>

## <a name="background-what-is-inheritance"></a><span data-ttu-id="94ef2-119">Hintergrund: Was ist Vererbung?</span><span class="sxs-lookup"><span data-stu-id="94ef2-119">Background: What is inheritance?</span></span>

<span data-ttu-id="94ef2-120">*Vererbung* ist eines der wichtigsten Attribute bei der objektorientierten Programmierung.</span><span class="sxs-lookup"><span data-stu-id="94ef2-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="94ef2-121">Sie können damit eine untergeordnete Klasse definieren, die das Verhalten einer übergeordneten Klasse wiederverwendet (erbt), erweitert oder ändert.</span><span class="sxs-lookup"><span data-stu-id="94ef2-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="94ef2-122">Die Klasse, deren Member geerbt werden, ist die *Basisklasse*.</span><span class="sxs-lookup"><span data-stu-id="94ef2-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="94ef2-123">Die Klasse, die die Member der Basisklasse erbt, ist die *abgeleitete Klasse*.</span><span class="sxs-lookup"><span data-stu-id="94ef2-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="94ef2-124">C# und .NET unterstützen nur die *einzelne Vererbung*.</span><span class="sxs-lookup"><span data-stu-id="94ef2-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="94ef2-125">D.h., eine Klasse kann nur von einer einzelnen Klasse erben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="94ef2-126">Allerdings ist Vererbung transitiv, sodass Sie eine Vererbungshierarchie für einen Satz von Typen definieren können.</span><span class="sxs-lookup"><span data-stu-id="94ef2-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="94ef2-127">Mit anderen Worten: Typ `D` kann von Typ `C` erben, der von Typ `B` erbt, der vom Basisklassentyp `A` erbt.</span><span class="sxs-lookup"><span data-stu-id="94ef2-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="94ef2-128">Da Vererbung transitiv ist, stehen die Member des Typs `A` Typ `D` zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="94ef2-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="94ef2-129">Nicht alle Member einer Basisklasse werden von abgeleiteten Klassen geerbt.</span><span class="sxs-lookup"><span data-stu-id="94ef2-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="94ef2-130">Die folgenden Member werden nicht geerbt:</span><span class="sxs-lookup"><span data-stu-id="94ef2-130">The following members are not inherited:</span></span>

- <span data-ttu-id="94ef2-131">[Statische Konstruktoren](../programming-guide/classes-and-structs/static-constructors.md), die die statischen Daten einer Klasse initialisieren.</span><span class="sxs-lookup"><span data-stu-id="94ef2-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="94ef2-132">[Instanzkonstruktoren](../programming-guide/classes-and-structs/constructors.md), die Sie aufrufen, um eine neue Instanz der Klasse zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="94ef2-133">Jede Klasse muss ihre eigenen Konstruktoren definieren.</span><span class="sxs-lookup"><span data-stu-id="94ef2-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="94ef2-134">[Finalizer](../programming-guide/classes-and-structs/destructors.md), die vom Garbage Collector der Laufzeit aufgerufen werden, um Instanzen einer Klasse zu zerstören.</span><span class="sxs-lookup"><span data-stu-id="94ef2-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="94ef2-135">Während alle anderen Member einer Basisklasse von abgeleiteten Klassen geerbt werden, hängt ihre Sichtbarkeit davon ab, ob auf sie zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="94ef2-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="94ef2-136">Ob auf einen Member zugegriffen werden kann, beeinflusst dessen Sichtbarkeit für abgeleitete Klassen wie folgt:</span><span class="sxs-lookup"><span data-stu-id="94ef2-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="94ef2-137">[Private](../language-reference/keywords/private.md) Member sind nur in abgeleiteten Klassen sichtbar, die in ihrer Basisklasse geschachtelt sind.</span><span class="sxs-lookup"><span data-stu-id="94ef2-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="94ef2-138">Andernfalls sind sie in abgeleiteten Klassen nicht sichtbar.</span><span class="sxs-lookup"><span data-stu-id="94ef2-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="94ef2-139">Im folgenden Beispiel ist `A.B` eine geschachtelte Klasse, die sich von `A` ableitet, und `C` leitet sich von `A` ab.</span><span class="sxs-lookup"><span data-stu-id="94ef2-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="94ef2-140">Das private Feld `A.value` ist in A.B sichtbar.</span><span class="sxs-lookup"><span data-stu-id="94ef2-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="94ef2-141">Wenn Sie jedoch die Kommentare aus der `C.GetValue`-Methode entfernen und versuchen, das Beispiel zu kompilieren, verursacht dies Compilerfehler CS0122: „Der Zugriff auf "A.value" ist aufgrund des Schutzgrads nicht möglich.“</span><span class="sxs-lookup"><span data-stu-id="94ef2-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="94ef2-142">[Geschützte](../language-reference/keywords/protected.md) Member sind nur in abgeleiteten Klassen sichtbar.</span><span class="sxs-lookup"><span data-stu-id="94ef2-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="94ef2-143">[Interne](../language-reference/keywords/internal.md) Member sind nur in abgeleiteten Klassen sichtbar, die sich in der gleichen Assembly wie die Basisklasse befinden.</span><span class="sxs-lookup"><span data-stu-id="94ef2-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="94ef2-144">Sie sind nicht in abgeleiteten Klassen sichtbar, die sich in einer anderen Assembly als die Basisklasse befinden.</span><span class="sxs-lookup"><span data-stu-id="94ef2-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="94ef2-145">[Öffentliche](../language-reference/keywords/public.md) Member sind in abgeleiteten Klassen sichtbar und Teil der öffentlichen Schnittstelle der abgeleiteten Klasse.</span><span class="sxs-lookup"><span data-stu-id="94ef2-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="94ef2-146">Öffentlich geerbte Member können so aufgerufen werden, als ob sie in der abgeleiteten Klasse definiert sind.</span><span class="sxs-lookup"><span data-stu-id="94ef2-146">Public inherited members can be called just as if they are defined in the derived class.</span></span> <span data-ttu-id="94ef2-147">Im folgenden Beispiel definiert Klasse `A` eine Methode namens `Method1`, und Klasse `B` erbt von Klasse `A`.</span><span class="sxs-lookup"><span data-stu-id="94ef2-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="94ef2-148">Das Beispiel ruft dann `Method1` auf, als wäre sie eine Instanzmethode von `B`.</span><span class="sxs-lookup"><span data-stu-id="94ef2-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="94ef2-149">Abgeleitete Klassen können auch geerbte Member *überschreiben*, indem sie eine alternative Implementierung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="94ef2-150">Um einen Member überschreiben zu können, muss der Member in der Basisklasse mit dem Schlüsselwort [virtual](../language-reference/keywords/virtual.md) markiert sein.</span><span class="sxs-lookup"><span data-stu-id="94ef2-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="94ef2-151">Standardmäßig sind Member der Basisklasse nicht als `virtual` markiert und können nicht überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="94ef2-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="94ef2-152">Der Versuch, wie im folgenden Beispiel einen nicht virtuellen Member zu überschreiben, verursacht den Compilerfehler CS0506: „"\<member>" : Der geerbte Member "\<member>" kann nicht überschrieben werden, da er nicht als "virtual", "abstract" oder "override" markiert ist.“</span><span class="sxs-lookup"><span data-stu-id="94ef2-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "\<member> cannot override inherited member \<member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="94ef2-153">In einigen Fällen *muss* eine abgeleitete Klasse die Basisklassenimplementierung überschreiben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="94ef2-154">Basisklassenmember, die mit dem Schlüsselwort [abstract](../language-reference/keywords/abstract.md) markiert sind, erfordern, dass abgeleitete Klassen sie überschreiben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="94ef2-155">Der Versuch, das folgende Beispiel zu kompilieren, verursacht den Compilerfehler CS0534: „Die &lt;Klasse&gt; implementiert den geerbten abstrakten Member &lt;Member&gt; nicht.“, da die Klasse `B` keine Implementierung für `A.Method1` bietet.</span><span class="sxs-lookup"><span data-stu-id="94ef2-155">Attempting to compile the following example generates compiler error CS0534, "&lt;class&gt; does not implement inherited abstract member &lt;member&gt;", because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="94ef2-156">Vererbung gilt nur für Klassen und Schnittstellen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="94ef2-157">Andere Typkategorien (Strukturen, Delegate und Enumerationen) unterstützen keine Vererbung.</span><span class="sxs-lookup"><span data-stu-id="94ef2-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="94ef2-158">Aufgrund dieser Regeln tritt beim Versuch, Codes wie den folgenden zu kompilieren, Compilerfehler CS0527 auf: Der Typ "Werttyp" in der Schnittstellenliste ist keine Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="94ef2-158">Because of these rules, attempting to compile code like the following example produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="94ef2-159">Die Fehlermeldung gibt an, dass die Vererbung nicht unterstützt wird, obwohl Sie die Schnittstellen definieren können, die eine Struktur implementiert.</span><span class="sxs-lookup"><span data-stu-id="94ef2-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="94ef2-160">Implizite Vererbung</span><span class="sxs-lookup"><span data-stu-id="94ef2-160">Implicit inheritance</span></span>

<span data-ttu-id="94ef2-161">Neben Typen, die sie vielleicht über die einzelne Vererbung erben, erben alle Typen im Typensystem von .NET implizit von <xref:System.Object> oder einem davon abgeleiteten Typ.</span><span class="sxs-lookup"><span data-stu-id="94ef2-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="94ef2-162">Die allgemeine Funktionalität von <xref:System.Object> ist für jeden beliebigen Typ verfügbar.</span><span class="sxs-lookup"><span data-stu-id="94ef2-162">The common functionality of <xref:System.Object> is available to any type.</span></span>

<span data-ttu-id="94ef2-163">Um zu sehen, was implizite Vererbung bedeutet, definieren wir eine neue Klasse `SimpleClass`, die einfach eine leere Klassendefinition ist:</span><span class="sxs-lookup"><span data-stu-id="94ef2-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="94ef2-164">Sie können dann die Reflektion (die Ihnen ermöglicht, die Metadaten eines Typs zu überprüfen, um Informationen zu diesem Typ zu erhalten) verwenden, um eine Liste der Member abzurufen, die zum `SimpleClass`-Typ gehören.</span><span class="sxs-lookup"><span data-stu-id="94ef2-164">You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="94ef2-165">Obwohl Sie keine Member in Ihrer `SimpleClass`-Klasse definiert haben, gibt die Ausgabe des Beispiels an, dass sie tatsächlich neun Member hat.</span><span class="sxs-lookup"><span data-stu-id="94ef2-165">Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="94ef2-166">Davon ist ein Member ein parameterloser (oder standardmäßiger) Konstruktor, der automatisch vom C#-Compiler für den `SimpleClass`-Typ angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="94ef2-166">One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="94ef2-167">Die verbleibenden acht sind Member von <xref:System.Object>, dem Typ, von dem alle Klassen und Schnittstellen im .NET-Typsystem letztlich implizit erben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="94ef2-168">Implizite Vererbung von der <xref:System.Object> -Klasse macht diese Methoden der `SimpleClass`-Klasse verfügbar:</span><span class="sxs-lookup"><span data-stu-id="94ef2-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="94ef2-169">Die öffentliche `ToString`-Methode, die ein `SimpleClass`-Objekt in seine Zeichenfolgendarstellung konvertiert, gibt den vollqualifizierten Typnamen zurück.</span><span class="sxs-lookup"><span data-stu-id="94ef2-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="94ef2-170">In diesem Fall gibt die `ToString`-Methode die Zeichenfolge „SimpleClass“ zurück.</span><span class="sxs-lookup"><span data-stu-id="94ef2-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="94ef2-171">Drei Methoden, die zwei Objekte auf Gleichheit testen: die öffentliche `Equals(Object)`-Instanzmethode, die öffentliche statische `Equals(Object, Object)`-Methode und die öffentliche statische `ReferenceEquals(Object, Object)`-Methode.</span><span class="sxs-lookup"><span data-stu-id="94ef2-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="94ef2-172">Standardmäßig testen diese Methoden auf Verweisgleichheit; d.h., um gleich zu sein, müssen zwei Objektvariablen auf das gleiche Objekt verweisen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="94ef2-173">Die öffentliche `GetHashCode`-Methode, die einen Wert, berechnet, der die Verwendung einer Instanz des Typs in Hashauflistungen ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="94ef2-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="94ef2-174">Die öffentliche `GetType` -Methode, die ein <xref:System.Type> -Objekt zurückgibt, das den `SimpleClass` -Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="94ef2-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="94ef2-175">Die geschützte <xref:System.Object.Finalize%2A> -Methode, die nicht verwaltete Ressourcen freigeben soll, bevor der Speicher eines Objekts durch den Garbage Collector freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="94ef2-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="94ef2-176">Die geschützte <xref:System.Object.MemberwiseClone%2A> -Methode, die einen flachen Klon des aktuellen Objekts erstellt.</span><span class="sxs-lookup"><span data-stu-id="94ef2-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="94ef2-177">Aufgrund der impliziten Vererbung können Sie alle geerbten Member aus einem `SimpleClass`-Objekt einfach aufrufen, als wären sie tatsächlich in der `SimpleClass`-Klasse definierte Member.</span><span class="sxs-lookup"><span data-stu-id="94ef2-177">Because of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="94ef2-178">Im folgenden Beispiel wird die `SimpleClass.ToString`-Methode aufgerufen, die `SimpleClass` von <xref:System.Object> erbt.</span><span class="sxs-lookup"><span data-stu-id="94ef2-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="94ef2-179">Die folgende Tabelle enthält die Kategorien von Typen, die Sie in C# erstellen können, und die Typen, von denen sie implizit erben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="94ef2-180">Jeder Basistyp macht implizit abgeleiteten Typen über Vererbung einen anderen Satz von Membern verfügbar.</span><span class="sxs-lookup"><span data-stu-id="94ef2-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="94ef2-181">Typkategorie</span><span class="sxs-lookup"><span data-stu-id="94ef2-181">Type category</span></span> | <span data-ttu-id="94ef2-182">Erbt implizit von</span><span class="sxs-lookup"><span data-stu-id="94ef2-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="94ef2-183">class</span><span class="sxs-lookup"><span data-stu-id="94ef2-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="94ef2-184">struct</span><span class="sxs-lookup"><span data-stu-id="94ef2-184">struct</span></span>        | <span data-ttu-id="94ef2-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="94ef2-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="94ef2-186">enum</span><span class="sxs-lookup"><span data-stu-id="94ef2-186">enum</span></span>          | <span data-ttu-id="94ef2-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="94ef2-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="94ef2-188">delegate</span><span class="sxs-lookup"><span data-stu-id="94ef2-188">delegate</span></span>      | <span data-ttu-id="94ef2-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="94ef2-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="94ef2-190">Vererbung und eine „ist ein“-Beziehung</span><span class="sxs-lookup"><span data-stu-id="94ef2-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="94ef2-191">Mit Vererbung wird normalerweise eine „ist ein“-Beziehung zwischen einer Basisklasse und einer oder mehreren abgeleiteten Klassen ausgedrückt, wobei die abgeleiteten Klassen spezialisierte Versionen der Basisklasse sind; die abgeleitete Klasse ist ein Typ der Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="94ef2-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="94ef2-192">Die `Publication`-Klasse stellt z.B. eine Publikation beliebiger Art dar, und die `Book`- und `Magazine`-Klasse stellen bestimmte Typen von Publikationen dar.</span><span class="sxs-lookup"><span data-stu-id="94ef2-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="94ef2-193">Eine Klasse oder Struktur kann eine oder mehrere Schnittstellen implementieren.</span><span class="sxs-lookup"><span data-stu-id="94ef2-193">A class or struct can implement one or more interfaces.</span></span> <span data-ttu-id="94ef2-194">Die Schnittstellenimplementierung wird zwar oft als Problemumgehung für einzelne Vererbung oder Möglichkeit der Verwendung von Vererbung mit Strukturen dargestellt, doch sie soll eine andere Beziehung (eine „tun können“-Beziehung) zwischen einer Schnittstelle und ihrem implementierenden Typ ausdrücken als Vererbung.</span><span class="sxs-lookup"><span data-stu-id="94ef2-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="94ef2-195">Eine Schnittstelle definiert eine Teilmenge der Funktionalität (z.B. die Möglichkeit zum Testen auf Gleichheit, zum Vergleichen oder Sortieren von Objekten oder zum Unterstützen kulturspezifischer Analyse und Formatierung), die die Schnittstelle den implementierenden Typen zur Verfügung stellt.</span><span class="sxs-lookup"><span data-stu-id="94ef2-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="94ef2-196">Beachten Sie, dass „ist ein“ auch die Beziehung zwischen einem Typ und einer bestimmten Instanziierung des betreffenden Typs ausdrückt.</span><span class="sxs-lookup"><span data-stu-id="94ef2-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="94ef2-197">Im folgenden Beispiel ist `Automobile` eine Klasse mit drei eindeutigen schreibgeschützten Eigenschaften: `Make`, der Autohersteller; `Model`, den Autotyp, und `Year`, das Herstellungsjahr.</span><span class="sxs-lookup"><span data-stu-id="94ef2-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="94ef2-198">Ihre `Automobile`-Klasse hat auch einen Konstruktor, dessen Argumente den Eigenschaftswerten zugewiesen werden. Er überschreibt die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode, um eine Zeichenfolge zu erzeugen, die eindeutig die `Automobile`-Instanz anstelle der `Automobile`-Klasse identifiziert.</span><span class="sxs-lookup"><span data-stu-id="94ef2-198">Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="94ef2-199">In diesem Fall sollten Sie sich nicht auf die Vererbung verlassen, um bestimmte Automarken und Modelle darzustellen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-199">In this case, you shouldn't rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="94ef2-200">Sie müssen z. B. keinen `Packard`-Typ definieren, um Autos darzustellen, die von der Packard Motor Car Company hergestellt werden.</span><span class="sxs-lookup"><span data-stu-id="94ef2-200">For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="94ef2-201">Stattdessen können Sie sie durch Erstellen eines `Automobile`-Objekts darstellen, wobei die entsprechenden Werten an dessen Klassenkonstruktor übergeben werden, wie im folgenden Beispiel dargestellt.</span><span class="sxs-lookup"><span data-stu-id="94ef2-201">Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="94ef2-202">Eine auf Vererbung basierende „ist ein“-Beziehung wird am besten auf eine Basisklasse und abgeleitete Klassen angewendet, die der Basisklasse weitere Member hinzufügen oder zusätzliche Funktionalität erfordern, die in der Basisklasse nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="94ef2-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="94ef2-203">Entwerfen der Basisklasse und abgeleiteter Klassen</span><span class="sxs-lookup"><span data-stu-id="94ef2-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="94ef2-204">Wir betrachten das Entwerfen einer Basisklasse und ihrer abgeleiteten Klassen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="94ef2-205">In diesem Abschnitt definieren Sie eine Basisklasse `Publication`, die eine beliebige Veröffentlichung darstellt, z. B. ein Buch, eine Zeitschrift, eine Zeitung, ein Journal, einen Artikel usw. Sie definieren auch eine `Book`-Klasse, die von `Publication` abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="94ef2-205">In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="94ef2-206">Sie könnten das Beispiel einfach erweitern, um andere abgeleitete Klassen wie `Magazine`, `Journal`, `Newspaper` und `Article` zu definieren.</span><span class="sxs-lookup"><span data-stu-id="94ef2-206">You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="94ef2-207">Die Basisklasse „Publication“</span><span class="sxs-lookup"><span data-stu-id="94ef2-207">The base Publication class</span></span>

<span data-ttu-id="94ef2-208">Beim Entwurf Ihrer `Publication`-Klasse müssen Sie einige Entwurfsentscheidungen treffen:</span><span class="sxs-lookup"><span data-stu-id="94ef2-208">In designing your `Publication` class, you need to make several design decisions:</span></span>

- <span data-ttu-id="94ef2-209">Welche Member sollen in Ihre Basisklasse `Publication` einbezogen werden? Sollen die `Publication`-Member Methodenimplementierungen bereitstellen, oder ist `Publication` eine abstrakte Basisklasse, die als Vorlage für ihre abgeleiteten Klassen dient?</span><span class="sxs-lookup"><span data-stu-id="94ef2-209">What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="94ef2-210">In diesem Fall stellt die `Publication`-Klasse Methodenimplementierungen bereit.</span><span class="sxs-lookup"><span data-stu-id="94ef2-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="94ef2-211">Der Abschnitt [Entwerfen abstrakter Basisklassen und ihrer abgeleiteten Klassen](#abstract) enthält ein Beispiel, in dem eine abstrakte Basisklasse verwendet wird, um die Methoden zu definieren, die abgeleitete Klassen überschreiben müssen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="94ef2-212">Abgeleitete Klassen können beliebige Implementierungen bereitstellen, die für den abgeleiteten Typ geeignet sind.</span><span class="sxs-lookup"><span data-stu-id="94ef2-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="94ef2-213">Die Möglichkeit zur Wiederverwendung von Code (d.h., mehrere abgeleitete Klassen nutzen gemeinsam die Deklaration und Implementierung von Basisklassenmethoden und müssen sie nicht überschreiben) ist ein Vorteil der nicht abstrakten Basisklassen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="94ef2-214">Daher sollten Sie `Publication` Member hinzufügen, wenn ihr Code vermutlich von einigen oder den meisten spezialisierten `Publication`-Typen gemeinsam genutzt wird.</span><span class="sxs-lookup"><span data-stu-id="94ef2-214">Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="94ef2-215">Wenn es Ihnen nicht gelingt, Basisklassenimplementierungen effizient bereitzustellen, müssen Sie letztendlich weitgehend identische Memberimplementierungen in abgeleiteten Klassen bereitstellen, statt einer einzelnen Implementierung in der Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="94ef2-215">If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="94ef2-216">Die Notwendigkeit, duplizierten Code an mehreren Standorten zu verwalten, ist eine potenzielle Fehlerquelle.</span><span class="sxs-lookup"><span data-stu-id="94ef2-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="94ef2-217">Um sowohl die Wiederverwendung von Codes zu maximieren als auch eine logische und intuitive Vererbungshierarchie zu erstellen, müssen Sie sichergehen, dass Sie in die `Publication`-Klasse nur die Daten und Funktionen einbeziehen, die alle bzw. die meisten Veröffentlichungen gemeinsam haben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="94ef2-218">Abgeleitete Klassen implementieren dann Member, die für die jeweiligen Publikationsarten, die sie darstellen, eindeutig sind.</span><span class="sxs-lookup"><span data-stu-id="94ef2-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="94ef2-219">Wie weit sollten Sie Ihre Klassenhierarchie erweitern?</span><span class="sxs-lookup"><span data-stu-id="94ef2-219">How far to extend your class hierarchy.</span></span> <span data-ttu-id="94ef2-220">Möchten Sie statt einer einzigen Basisklasse und einer oder mehreren abgeleiteten Klassen eine Hierarchie von mindestens drei Klassen entwickeln?</span><span class="sxs-lookup"><span data-stu-id="94ef2-220">Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="94ef2-221">Beispielsweise könnte `Publication` eine Basisklasse von `Periodical` sein, was wiederum eine Basisklasse von `Magazine`, `Journal` und `Newspaper` ist.</span><span class="sxs-lookup"><span data-stu-id="94ef2-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="94ef2-222">Für Ihr Beispiel verwenden Sie die flache Hierarchie einer `Publication`-Klasse und einer einzelnen abgeleiteten Klasse `Book`.</span><span class="sxs-lookup"><span data-stu-id="94ef2-222">For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`.</span></span> <span data-ttu-id="94ef2-223">Sie könnten das Beispiel mühelos erweitern, um eine Reihe von zusätzlichen Klassen zu erstellen, die von `Publication` abgeleitet sind, z. B. `Magazine` und `Article`.</span><span class="sxs-lookup"><span data-stu-id="94ef2-223">You could easily extend the example to create a number of additional classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="94ef2-224">Ist es sinnvoll, die Basisklasse zu instanziieren?</span><span class="sxs-lookup"><span data-stu-id="94ef2-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="94ef2-225">Wenn das nicht der Fall ist, wenden Sie das Schlüsselwort [abstract](../language-reference/keywords/abstract.md) auf die Klasse an.</span><span class="sxs-lookup"><span data-stu-id="94ef2-225">If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="94ef2-226">Andernfalls kann Ihre `Publication`-Klasse durch Aufruf ihres Klassenkonstruktors instanziiert werden.</span><span class="sxs-lookup"><span data-stu-id="94ef2-226">Otherwise, your `Publication` class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="94ef2-227">Wenn versucht wird, eine mit dem `abstract`-Schlüsselwort markierte Klasse durch einen direkten Aufruf ihres Klassenkonstruktors zu instanziieren, generiert der C#-Compiler den Fehler CS0144: „Es konnte keine Instanz der abstrakten Klasse oder Schnittstelle erstellt werden.“</span><span class="sxs-lookup"><span data-stu-id="94ef2-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="94ef2-228">Wenn versucht wird, die Klasse mithilfe der Reflektion zu instanziieren, löst die Reflektionsmethode eine <xref:System.MemberAccessException> aus.</span><span class="sxs-lookup"><span data-stu-id="94ef2-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span>

  <span data-ttu-id="94ef2-229">Standardmäßig kann eine Basisklasse durch Aufruf ihres Klassenkonstruktors instanziiert werden.</span><span class="sxs-lookup"><span data-stu-id="94ef2-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="94ef2-230">Sie müssen keinen Klassenkonstruktor explizit definieren.</span><span class="sxs-lookup"><span data-stu-id="94ef2-230">You do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="94ef2-231">Wenn im Quellcode der Basisklasse keiner vorhanden ist, stellt der C#-Compiler automatisch einen (parameterlosen) Standardkonstruktor bereit.</span><span class="sxs-lookup"><span data-stu-id="94ef2-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="94ef2-232">In Ihrem Beispiel markieren Sie die `Publication`-Klasse als [abstract](../language-reference/keywords/abstract.md), sodass sie nicht instanziiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="94ef2-232">For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>  <span data-ttu-id="94ef2-233">Eine `abstract`-Klasse ohne `abstract`-Methoden zeigt an, dass diese Klasse ein abstraktes Konzept darstellt, das von mehreren konkreten Klassen geteilt wird (z. B. `Book` und `Journal`).</span><span class="sxs-lookup"><span data-stu-id="94ef2-233">An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`).</span></span>

- <span data-ttu-id="94ef2-234">Müssen abgeleitete Klassen die Implementierung der Basisklasse eines bestimmten Members erben, können sie die Implementierung der Basisklasse optional überschreiben, oder müssen sie eine Implementierung bereitstellen?</span><span class="sxs-lookup"><span data-stu-id="94ef2-234">Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation.</span></span> <span data-ttu-id="94ef2-235">Mit dem Schlüsselwort [abstract](../language-reference/keywords/abstract.md) können Sie abgeleitete Klassen dazu zwingen, eine Implementierung bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-235">You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation.</span></span> <span data-ttu-id="94ef2-236">Mit dem Schlüsselwort [virtual](../language-reference/keywords/virtual.md) können Sie abgeleiteten Klassen erlauben, eine Basisklassenmethode zu überschreiben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-236">You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="94ef2-237">Standardmäßig können in der Basisklasse definierte Methoden *nicht* überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="94ef2-237">By default, methods defined in the base class are *not* overridable.</span></span>

  <span data-ttu-id="94ef2-238">Die `Publication`-Klasse hat keine `abstract`-Methoden, ist allerdings selbst `abstract`.</span><span class="sxs-lookup"><span data-stu-id="94ef2-238">The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`.</span></span>

- <span data-ttu-id="94ef2-239">Stellt eine abgeleitete Klasse die endgültige Klasse in der Vererbungshierarchie dar und kann nicht selbst als Basisklasse für weitere abgeleitete Klassen verwendet werden?</span><span class="sxs-lookup"><span data-stu-id="94ef2-239">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="94ef2-240">Standardmäßig kann jede Klasse als Basisklasse dienen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-240">By default, any class can serve as a base class.</span></span> <span data-ttu-id="94ef2-241">Sie können das [sealed](../language-reference/keywords/sealed.md)-Schlüsselwort anwenden, um anzugeben, dass eine Klasse nicht als Basisklasse für zusätzliche Klassen dienen kann.</span><span class="sxs-lookup"><span data-stu-id="94ef2-241">You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="94ef2-242">Beim Versuch der Ableitung von einer versiegelten Klasse wird der Compilerfehler CS0509 generiert: „Vom versiegelten Typ \<typeName> kann nicht abgeleitet werden“.</span><span class="sxs-lookup"><span data-stu-id="94ef2-242">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type \<typeName>".</span></span>

  <span data-ttu-id="94ef2-243">Für Ihr Beispiel markieren Sie Ihre abgeleitete Klasse als `sealed`.</span><span class="sxs-lookup"><span data-stu-id="94ef2-243">For your example, you'll mark your derived class as `sealed`.</span></span>

<span data-ttu-id="94ef2-244">Das folgende Beispiel zeigt sowohl den Quellcode für die `Publication`-Klasse als auch eine `PublicationType`-Enumeration, die von der Eigenschaft `Publication.PublicationType` zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="94ef2-244">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="94ef2-245">Zusätzlich zu den Membern, die sie von <xref:System.Object> erbt, definiert die `Publication`-Klasse die folgenden eindeutigen Member und Memberüberschreibungen:</span><span class="sxs-lookup"><span data-stu-id="94ef2-245">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="94ef2-246">Ein Konstruktor</span><span class="sxs-lookup"><span data-stu-id="94ef2-246">A constructor</span></span>

  <span data-ttu-id="94ef2-247">Da die `Publication`-Klasse `abstract` ist, kann sie nicht direkt von Codes wie dem folgenden aus instanziiert werden:</span><span class="sxs-lookup"><span data-stu-id="94ef2-247">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="94ef2-248">Ihr Instanzkonstruktor kann jedoch direkt von abgeleiteten Klassenkonstruktoren aufgerufen werden, wie der Quellcode für die `Book`-Klasse veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="94ef2-248">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="94ef2-249">Zwei publikationsbezogene Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="94ef2-249">Two publication-related properties</span></span>

  <span data-ttu-id="94ef2-250">`Title` ist eine schreibgeschützte <xref:System.String>-Eigenschaft, deren Wert durch Aufrufen des `Publication`-Konstruktors bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="94ef2-250">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="94ef2-251">`Pages` ist eine schreibgeschützte Eigenschaft <xref:System.Int32>, die angibt, wie viele Seiten die Publikation insgesamt hat.</span><span class="sxs-lookup"><span data-stu-id="94ef2-251">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="94ef2-252">Der Wert wird in einem privaten Feld namens `totalPages` gespeichert.</span><span class="sxs-lookup"><span data-stu-id="94ef2-252">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="94ef2-253">Er muss eine positive Zahl sein; andernfalls wird eine <xref:System.ArgumentOutOfRangeException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="94ef2-253">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="94ef2-254">Herausgeberbezogene Elemente</span><span class="sxs-lookup"><span data-stu-id="94ef2-254">Publisher-related members</span></span>

  <span data-ttu-id="94ef2-255">Zwei schreibgeschützte Eigenschaften, `Publisher` und `Type`.</span><span class="sxs-lookup"><span data-stu-id="94ef2-255">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="94ef2-256">Die Werte werden ursprünglich durch den Aufruf des `Publication`-Klassenkonstruktors abgerufen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-256">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="94ef2-257">Veröffentlichungsbezogene Elemente</span><span class="sxs-lookup"><span data-stu-id="94ef2-257">Publishing-related members</span></span>

  <span data-ttu-id="94ef2-258">Zwei Methoden, `Publish` und `GetPublicationDate`, legen das Veröffentlichungsdatum fest und geben es zurück.</span><span class="sxs-lookup"><span data-stu-id="94ef2-258">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="94ef2-259">Die `Publish`-Methode setzt ein privates `published`-Flag auf `true`, wenn sie aufgerufen wird, und weist das ihr übergebene Datum als Argument dem privaten Feld `datePublished` zu.</span><span class="sxs-lookup"><span data-stu-id="94ef2-259">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="94ef2-260">Die `GetPublicationDate`-Methode gibt die Zeichenfolge „NYP“ zurück, wenn das `published`-Flag `false` ist, und den Wert des Felds `datePublished`, wenn es `true` ist.</span><span class="sxs-lookup"><span data-stu-id="94ef2-260">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="94ef2-261">Copyrightbezogene Elemente</span><span class="sxs-lookup"><span data-stu-id="94ef2-261">Copyright-related members</span></span>

  <span data-ttu-id="94ef2-262">Die Methode `Copyright` übernimmt den Namen des Urheberrechtsinhabers und das Jahr des Copyrights als Argumente und weist sie den Eigenschaften `CopyrightName` und `CopyrightDate` zu.</span><span class="sxs-lookup"><span data-stu-id="94ef2-262">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="94ef2-263">Eine Überschreibung der `ToString`-Methode</span><span class="sxs-lookup"><span data-stu-id="94ef2-263">An override of the `ToString` method</span></span>

  <span data-ttu-id="94ef2-264">Wenn ein Typ die <xref:System.Object.ToString%2A?displayProperty=nameWithType> -Methode nicht überschreibt, gibt sie den vollqualifizierten Namen des Typs zurück, was zur Unterscheidung einer Instanz von einer anderen von geringem Nutzen ist.</span><span class="sxs-lookup"><span data-stu-id="94ef2-264">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="94ef2-265">Die `Publication`-Klasse überschreibt <xref:System.Object.ToString%2A?displayProperty=nameWithType>, um den Wert der Eigenschaft `Title` zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-265">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="94ef2-266">Die folgende Abbildung veranschaulicht die Beziehung zwischen Ihrer Basisklasse `Publication` und der implizit geerbten Klasse <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="94ef2-266">The following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Die Klassen „Object“ und „Publication“](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="94ef2-268">Die `Book`-Klasse</span><span class="sxs-lookup"><span data-stu-id="94ef2-268">The `Book` class</span></span>

<span data-ttu-id="94ef2-269">Die `Book`-Klasse stellt ein Buch als einen speziellen Typ der Publikation dar.</span><span class="sxs-lookup"><span data-stu-id="94ef2-269">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="94ef2-270">Das folgende Beispiel zeigt den Quellcode für die `Book`-Klasse.</span><span class="sxs-lookup"><span data-stu-id="94ef2-270">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="94ef2-271">Zusätzlich zu den Membern, die sie von `Publication` erbt, definiert die `Book`-Klasse die folgenden eindeutigen Member und Memberüberschreibungen:</span><span class="sxs-lookup"><span data-stu-id="94ef2-271">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="94ef2-272">Zwei Konstruktoren</span><span class="sxs-lookup"><span data-stu-id="94ef2-272">Two constructors</span></span>

  <span data-ttu-id="94ef2-273">Die beiden `Book`-Konstruktoren nutzen gemeinsam drei allgemeine Parameter.</span><span class="sxs-lookup"><span data-stu-id="94ef2-273">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="94ef2-274">Zwei, *title* und *publisher*, entsprechen den Parametern des `Publication`-Konstruktors.</span><span class="sxs-lookup"><span data-stu-id="94ef2-274">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="94ef2-275">Der dritte ist *author*, der in einer öffentlichen unveränderlichen `Author`-Eigenschaft gespeichert ist.</span><span class="sxs-lookup"><span data-stu-id="94ef2-275">The third is *author*, which is stored to a public immutable `Author` property.</span></span> <span data-ttu-id="94ef2-276">Ein Konstruktor enthält einen *ISBN*-Parameter, der in der Auto-Eigenschaft `ISBN` gespeichert ist.</span><span class="sxs-lookup"><span data-stu-id="94ef2-276">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="94ef2-277">Der erste Konstruktor verwendet das [this](../language-reference/keywords/this.md)-Schlüsselwort, um den anderen Konstruktor aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-277">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="94ef2-278">Die Konstruktorverkettung ist ein häufiges Muster beim Definieren von Konstruktoren.</span><span class="sxs-lookup"><span data-stu-id="94ef2-278">Constructor chaining is a common pattern in defining constructors.</span></span> <span data-ttu-id="94ef2-279">Konstruktoren mit weniger Parametern stellen beim Aufrufen des Konstruktors mit der größten Anzahl von Parametern Standardwerte zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="94ef2-279">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="94ef2-280">Der zweite Konstruktor verwendet das [base](../language-reference/keywords/base.md)-Schlüsselwort, um Titel und Herausgebername an den Basisklassenkonstruktor zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-280">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="94ef2-281">Wenn Ihr Quellcode keinen expliziten Aufruf eines Basisklassenkonstruktors enthält, stellt der C#-Compiler automatisch einen Aufruf des standardmäßigen oder parameterlosen Konstruktors der Basisklasse bereit.</span><span class="sxs-lookup"><span data-stu-id="94ef2-281">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="94ef2-282">Eine schreibgeschützte Eigenschaft `ISBN`, die die ISBN des `Book`-Objekts zurückgibt, eine eindeutige 10- oder 13-stellige Nummer.</span><span class="sxs-lookup"><span data-stu-id="94ef2-282">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="94ef2-283">Die ISBN wird einem der `Book`-Konstruktoren als Argument übergeben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-283">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="94ef2-284">Die ISBN wird in einem privaten Unterstützungsfeld gespeichert, das automatisch vom Compiler generiert wird.</span><span class="sxs-lookup"><span data-stu-id="94ef2-284">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="94ef2-285">Eine schreibgeschützte Eigenschaft `Author`.</span><span class="sxs-lookup"><span data-stu-id="94ef2-285">A read-only `Author` property.</span></span> <span data-ttu-id="94ef2-286">Der Autorenname wird als Argument beiden `Book`-Konstruktoren übergeben und in der Eigenschaft gespeichert.</span><span class="sxs-lookup"><span data-stu-id="94ef2-286">The author name is supplied as an argument to both `Book` constructors and is stored in the property.</span></span>

- <span data-ttu-id="94ef2-287">Zwei schreibgeschützte preisbezogene Eigenschaften, `Price` und `Currency`.</span><span class="sxs-lookup"><span data-stu-id="94ef2-287">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="94ef2-288">Ihre Werte werden in einem Aufruf der `SetPrice`-Methode als Argumente bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="94ef2-288">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="94ef2-289">Die Eigenschaft `Currency` ist das dreistellige ISO-Währungssymbol (z. B. USD für den US-Dollar).</span><span class="sxs-lookup"><span data-stu-id="94ef2-289">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar).</span></span> <span data-ttu-id="94ef2-290">ISO-Währungssymbole können aus der Eigenschaft <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="94ef2-290">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span> <span data-ttu-id="94ef2-291">Diese beiden Eigenschaften sind aus externer Richtung schreibgeschützt, aber beide können durch Code in der `Book`-Klasse festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="94ef2-291">Both of these properties are externally read-only, but both can be set by code in the `Book` class.</span></span>

- <span data-ttu-id="94ef2-292">Eine `SetPrice`-Methode, die die Werte der Eigenschaften `Price` und `Currency` festlegt.</span><span class="sxs-lookup"><span data-stu-id="94ef2-292">A `SetPrice` method, which sets the values of the `Price` and `Currency` properties.</span></span> <span data-ttu-id="94ef2-293">Diese Werte werden von diesen selben Eigenschaften zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-293">Those values are returned by those same properties.</span></span>

- <span data-ttu-id="94ef2-294">Überschreibt die `ToString`-Methode (geerbt von `Publication`) und die Methoden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> und <xref:System.Object.GetHashCode%2A> (geerbt von <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="94ef2-294">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="94ef2-295">Sofern sie nicht überschrieben wird, führt die Methode <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Tests hinsichtlich der Verweisgleichheit durch.</span><span class="sxs-lookup"><span data-stu-id="94ef2-295">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="94ef2-296">D.h., zwei Objektvariablen werden als gleich betrachtet, wenn sie auf das gleiche Objekt verweisen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-296">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="94ef2-297">Andererseits sollten in der `Book`-Klasse zwei `Book`-Objekte gleich sein, wenn sie die gleiche ISBN haben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-297">In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="94ef2-298">Wenn Sie die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode überschreiben, müssen Sie auch die <xref:System.Object.GetHashCode%2A>-Methode überschreiben. Diese gibt einen Wert zurück, den die Laufzeit zum Speichern von Elementen in Hashauflistungen für einen effizienten Abruf verwendet.</span><span class="sxs-lookup"><span data-stu-id="94ef2-298">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="94ef2-299">Der Hashcode sollte einen Wert zurückgeben, der mit dem Test auf Gleichheit konsistent ist.</span><span class="sxs-lookup"><span data-stu-id="94ef2-299">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="94ef2-300">Da Sie <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> überschrieben haben, sodass `true` zurückgegeben wird, wenn die ISBN-Eigenschaften von zwei `Book`-Objekten gleich sind, geben Sie den Hash zurück, der durch Aufrufen der <xref:System.String.GetHashCode%2A>-Methode der von der Eigenschaft `ISBN` zurückgegebenen Zeichenfolge berechnet wurde.</span><span class="sxs-lookup"><span data-stu-id="94ef2-300">Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="94ef2-301">Die folgende Abbildung veranschaulicht die Beziehung zwischen der `Book`-Klasse und `Publication`, ihrer Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="94ef2-301">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Die Klassen „Publication“ und „Book“](media/book-class.jpg)

<span data-ttu-id="94ef2-303">Sie können jetzt ein `Book`-Objekt instanziieren, sowohl dessen eindeutige als auch geerbte Member aufrufen und es als Argument an eine Methode übergeben, die einen Parameter des Typs `Publication` oder `Book` erwartet, wie im folgenden Beispiel dargestellt.</span><span class="sxs-lookup"><span data-stu-id="94ef2-303">You can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="94ef2-304">Entwerfen abstrakter Basisklassen und der von ihnen abgeleiteten Klassen</span><span class="sxs-lookup"><span data-stu-id="94ef2-304">Designing abstract base classes and their derived classes</span></span>

<a name="abstract"></a>

<span data-ttu-id="94ef2-305">Im vorherigen Beispiel haben Sie eine Basisklasse definiert, die eine Implementierung für eine Reihe von Methoden bereitstellte, um abgeleiteten Klassen die gemeinsame Codenutzung zu erlauben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-305">In the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="94ef2-306">In vielen Fällen wird jedoch nicht erwartet, dass die Basisklasse eine Implementierung bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="94ef2-306">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="94ef2-307">Stattdessen ist die Basisklasse eine *abstrakte Klasse*, die *abstrakte Methoden* deklariert. Sie dient als Vorlage, die die Member definiert, die jede abgeleitete Klasse implementieren muss.</span><span class="sxs-lookup"><span data-stu-id="94ef2-307">Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="94ef2-308">In einer abstrakten Basisklasse ist die Implementierung jedes abgeleiteten Typs in der Regel für diesen Typ eindeutig.</span><span class="sxs-lookup"><span data-stu-id="94ef2-308">Typically in an abstract base class, the implementation of each derived type is unique to that type.</span></span> <span data-ttu-id="94ef2-309">Sie haben die Klasse mit dem Schlüsselwort „abstract“ markiert, weil ein `Publication`-Objekt nicht instanziiert werden sollte, obwohl die Klasse für Veröffentlichungen übliche Funktionsimplementierungen bereitgestellt hat.</span><span class="sxs-lookup"><span data-stu-id="94ef2-309">You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications.</span></span>

<span data-ttu-id="94ef2-310">Jede geschlossene zweidimensionale geometrische Form besitzt beispielsweise zwei Eigenschaften: den Flächeninhalt, die innere Ausdehnung der Form; und den Umfang, d.h. die Länge der Kanten der Form.</span><span class="sxs-lookup"><span data-stu-id="94ef2-310">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="94ef2-311">Wie diese Eigenschaften berechnet werden, hängt jedoch vollständig von der jeweiligen Form ab.</span><span class="sxs-lookup"><span data-stu-id="94ef2-311">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="94ef2-312">Die Formel zum Berechnen des Umfangs eines Kreises unterscheidet sich beispielsweise von der Formel zum Berechnen des Umfangs eines Dreiecks.</span><span class="sxs-lookup"><span data-stu-id="94ef2-312">The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle.</span></span> <span data-ttu-id="94ef2-313">Die `Shape`-Klasse ist eine `abstract`-Klasse mit `abstract`-Methoden.</span><span class="sxs-lookup"><span data-stu-id="94ef2-313">The `Shape` class is an `abstract` class with `abstract` methods.</span></span> <span data-ttu-id="94ef2-314">Das bedeutet, dass abgeleitete Klassen die gleiche Funktionalität haben, diese Funktionalität jedoch unterschiedlich implementieren.</span><span class="sxs-lookup"><span data-stu-id="94ef2-314">That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.</span></span>

<span data-ttu-id="94ef2-315">Das folgende Beispiel definiert eine abstrakte Basisklasse mit dem Namen `Shape`, die zwei Eigenschaften definiert: `Area` und `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="94ef2-315">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="94ef2-316">Jede Klasse wird mit dem [abstract](../language-reference/keywords/abstract.md)-Schlüsselwort markiert und auch jeder Instanzmember wird mit dem [abstract](../language-reference/keywords/abstract.md)-Schlüsselwort markiert.</span><span class="sxs-lookup"><span data-stu-id="94ef2-316">In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="94ef2-317">In diesem Fall überschreibt `Shape` auch die <xref:System.Object.ToString%2A?displayProperty=nameWithType> -Methode, um den Namen des Typs anstelle dessen vollqualifizierten Namens zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-317">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="94ef2-318">Außerdem definiert sie zwei statische Member, `GetArea` und `GetPerimeter`, die Aufrufern ermöglichen, mühelos Fläche und Umfang einer Instanz einer beliebigen abgeleiteten Klasse abzurufen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-318">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="94ef2-319">Wenn Sie eine Instanz einer abgeleiteten Klasse an eine der beiden Methoden übergeben, ruft die Laufzeit die Methodenüberschreibung der abgeleiteten Klasse auf.</span><span class="sxs-lookup"><span data-stu-id="94ef2-319">When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="94ef2-320">Dann können Sie einige Klassen von `Shape` ableiten, die bestimmte Formen darstellen.</span><span class="sxs-lookup"><span data-stu-id="94ef2-320">You can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="94ef2-321">Das folgende Beispiel definiert drei Klassen, `Triangle`, `Rectangle` und `Circle`.</span><span class="sxs-lookup"><span data-stu-id="94ef2-321">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="94ef2-322">Jede verwendet eine Formel, die für die Berechnung von Fläche und Umfang der betreffenden Form eindeutig ist.</span><span class="sxs-lookup"><span data-stu-id="94ef2-322">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="94ef2-323">Einige der abgeleiteten Klassen definieren auch Eigenschaften, z.B. `Rectangle.Diagonal` und `Circle.Diameter`, die für die Form, die sie darstellen, eindeutig sind.</span><span class="sxs-lookup"><span data-stu-id="94ef2-323">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="94ef2-324">Im folgenden Beispiel werden von `Shape` abgeleitete Objekte verwendet.</span><span class="sxs-lookup"><span data-stu-id="94ef2-324">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="94ef2-325">Es instanziiert ein Array von Objekten, die von `Shape` abgeleitet sind, und ruft die statischen Methoden der `Shape`-Klasse auf, deren Umschließungen `Shape`-Eigenschaftswerte zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="94ef2-325">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="94ef2-326">Die Laufzeit ruft Werte aus den überschriebenen Eigenschaften der abgeleiteten Typen ab.</span><span class="sxs-lookup"><span data-stu-id="94ef2-326">The runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="94ef2-327">Das Beispiel wandelt auch jedes `Shape` -Objekt im Array in seinen abgeleiteten Typ um, und wenn die Umwandlung erfolgreich ist, ruft es Eigenschaften dieser bestimmten Unterklasse von `Shape` auf.</span><span class="sxs-lookup"><span data-stu-id="94ef2-327">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="94ef2-328">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="94ef2-328">See also</span></span>

- [<span data-ttu-id="94ef2-329">Vererbung (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="94ef2-329">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
