---
title: Transaktionen
ms.date: 09/08/2020
description: Hier erfahren Sie, wie Sie Transaktionen einsetzen.
ms.openlocfilehash: 50c4cd1023eac892cafc3ae4395e9168bd8e9f36
ms.sourcegitcommit: aa6d8a90a4f5d8fe0f6e967980b8c98433f05a44
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 09/16/2020
ms.locfileid: "90678861"
---
# <a name="transactions"></a><span data-ttu-id="97f4a-103">Transaktionen</span><span class="sxs-lookup"><span data-stu-id="97f4a-103">Transactions</span></span>

<span data-ttu-id="97f4a-104">Mit Transaktionen können Sie mehrere SQL-Anweisungen in einer einzelnen Arbeitseinheit gruppieren, die als unteilbare Einheit an die Datenbank übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="97f4a-104">Transactions let you group multiple SQL statements into a single unit of work that is committed to the database as one atomic unit.</span></span> <span data-ttu-id="97f4a-105">Schlägt eine Anweisung innerhalb der Transaktion fehl, können die durch die vorherigen Anweisungen vorgenommenen Änderungen durch ein Rollback rückgängig gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="97f4a-105">If any statement in the transaction fails, changes made by the previous statements can be rolled back.</span></span> <span data-ttu-id="97f4a-106">Der Anfangszustand der Datenbank vor Beginn der Transaktion wird beibehalten.</span><span class="sxs-lookup"><span data-stu-id="97f4a-106">The initial state of the database when the transaction was started is preserved.</span></span> <span data-ttu-id="97f4a-107">Bei der gleichzeitigen Ausführung von zahlreichen Änderungen können Sie durch den Einsatz einer Transaktion auch die Leistung von SQLite verbessern.</span><span class="sxs-lookup"><span data-stu-id="97f4a-107">Using a transaction can also improve performance on SQLite when making numerous changes to the database at once.</span></span>

## <a name="concurrency"></a><span data-ttu-id="97f4a-108">Parallelität</span><span class="sxs-lookup"><span data-stu-id="97f4a-108">Concurrency</span></span>

<span data-ttu-id="97f4a-109">In SQLite darf jeweils nur eine Transaktion über ausstehende Änderungen in der Datenbank verfügen.</span><span class="sxs-lookup"><span data-stu-id="97f4a-109">In SQLite, only one transaction is allowed to have changes pending in the database at a time.</span></span> <span data-ttu-id="97f4a-110">Daher kann bei einem Aufruf der Methoden <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> und `Execute` in der <xref:Microsoft.Data.Sqlite.SqliteCommand>-Klasse ein Timeout auftreten, wenn die Ausführung einer anderen Transaktion zu lange dauert.</span><span class="sxs-lookup"><span data-stu-id="97f4a-110">Because of this, calls to <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> and the `Execute` methods on <xref:Microsoft.Data.Sqlite.SqliteCommand> may time out if another transaction takes too long to complete.</span></span>

<span data-ttu-id="97f4a-111">Weitere Informationen zu Sperren, erneuten Versuchen und Timeouts finden Sie unter [Datenbankfehler](database-errors.md).</span><span class="sxs-lookup"><span data-stu-id="97f4a-111">For more information about locking, retries, and timeouts, see [Database errors](database-errors.md).</span></span>

## <a name="isolation-levels"></a><span data-ttu-id="97f4a-112">Isolationsgrade</span><span class="sxs-lookup"><span data-stu-id="97f4a-112">Isolation levels</span></span>

<span data-ttu-id="97f4a-113">Standardmäßig sind Transaktionen in SQLite **serialisierbar**.</span><span class="sxs-lookup"><span data-stu-id="97f4a-113">Transactions are **serializable** by default in SQLite.</span></span> <span data-ttu-id="97f4a-114">Mit dieser Isolationsstufe wird sichergestellt, dass alle innerhalb einer Transaktion vorgenommenen Änderungen vollständig isoliert sind.</span><span class="sxs-lookup"><span data-stu-id="97f4a-114">This isolation level guarantees that any changes made within a transaction are completely isolated.</span></span> <span data-ttu-id="97f4a-115">Außerhalb der Transaktion ausgeführte Anweisungen sind von den Änderungen der Transaktion nicht betroffen.</span><span class="sxs-lookup"><span data-stu-id="97f4a-115">Other statements executed outside of the transaction aren't affected by the transaction's changes.</span></span>

<span data-ttu-id="97f4a-116">Bei Verwendung eines freigegebenen Caches unterstützt SQLite auch die Isolationsstufe **Lesen ohne Commit**.</span><span class="sxs-lookup"><span data-stu-id="97f4a-116">SQLite also supports **read uncommitted** when using a shared cache.</span></span> <span data-ttu-id="97f4a-117">In dieser Stufe sind „Dirty Reads“, nicht wiederholbare Lesevorgänge und Phantomlesevorgänge zulässig:</span><span class="sxs-lookup"><span data-stu-id="97f4a-117">This level allows dirty reads, nonrepeatable reads, and phantoms:</span></span>

- <span data-ttu-id="97f4a-118">Bei einem *Dirty Read* genannten Lesevorgang werden in einer Transaktion ausstehende Änderungen von einer Abfrage außerhalb der Transaktion zurückgegeben. Für die Änderungen innerhalb der Transaktion wird jedoch ein Rollback ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="97f4a-118">A *dirty read* occurs when changes pending in one transaction are returned by a query outside of the transaction, but the changes in the transaction are rolled back.</span></span> <span data-ttu-id="97f4a-119">Die Ergebnisse enthalten Daten, für die kein echter Commit in der Datenbank ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="97f4a-119">The results contain data that was never actually committed to the database.</span></span>

- <span data-ttu-id="97f4a-120">Bei einem *nicht wiederholbaren Lesevorgang* wird eine Zeile zweimal von einer Transaktion abgefragt, jedoch mit unterschiedlichen Ergebnissen, da die Zeile zwischen den beiden Abfragen von einer anderen Transaktion geändert wurde.</span><span class="sxs-lookup"><span data-stu-id="97f4a-120">A *nonrepeatable read* occurs when a transaction queries same row twice, but the results are different because it was changed between the two queries by another transaction.</span></span>

- <span data-ttu-id="97f4a-121">Bei einem *Phantomlesevorgang* sind Zeilen vorhanden, die zur Erfüllung der WHERE-Klausel einer Abfrage während einer Transaktion geändert oder hinzugefügt wurden.</span><span class="sxs-lookup"><span data-stu-id="97f4a-121">*Phantoms* are rows that get changed or added to meet the where clause of a query during a transaction.</span></span> <span data-ttu-id="97f4a-122">Ist ein solcher Vorgang zulässig, kann eine Abfrage unterschiedliche Zeilen zurückgeben, wenn sie zweimal in derselben Transaktion ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="97f4a-122">If allowed, the same query could return different rows when executed twice in the same transaction.</span></span>

<span data-ttu-id="97f4a-123">Microsoft.Data.Sqlite behandelt den für „IsolationLevel“ an <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> übergegebenen Wert als Mindeststufe.</span><span class="sxs-lookup"><span data-stu-id="97f4a-123">Microsoft.Data.Sqlite treats the IsolationLevel passed to <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> as a minimum level.</span></span> <span data-ttu-id="97f4a-124">Die tatsächliche Isolationsstufe wird höhergestuft auf „Lesen ohne Commit“ oder „serialisierbar“.</span><span class="sxs-lookup"><span data-stu-id="97f4a-124">The actual isolation level will be promoted to either read uncommitted or serializable.</span></span>

<span data-ttu-id="97f4a-125">Mit dem folgenden Code wird ein „Dirty Read“ simuliert.</span><span class="sxs-lookup"><span data-stu-id="97f4a-125">The following code simulates a dirty read.</span></span> <span data-ttu-id="97f4a-126">Beachten Sie, dass die Verbindungszeichenfolge `Cache=Shared` enthalten muss.</span><span class="sxs-lookup"><span data-stu-id="97f4a-126">Note, the connection string must include `Cache=Shared`.</span></span>

[!code-csharp[](../../../../samples/snippets/standard/data/sqlite/DirtyReadSample/Program.cs?name=snippet_DirtyRead)]

## <a name="deferred-transactions"></a><span data-ttu-id="97f4a-127">Verzögerte Transaktionen</span><span class="sxs-lookup"><span data-stu-id="97f4a-127">Deferred transactions</span></span>

<span data-ttu-id="97f4a-128">Ab der Version 5.0 von Microsoft.Data.Sqlite können Transaktionen verzögert werden.</span><span class="sxs-lookup"><span data-stu-id="97f4a-128">Starting with Microsoft.Data.Sqlite version 5.0, transactions can be deferred.</span></span> <span data-ttu-id="97f4a-129">Dadurch wird die Erstellung der tatsächlichen Transaktion in der Datenbank so lange verzögert, bis der erste Befehl ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="97f4a-129">This defers the creation of the actual transaction in the database until the first command is executed.</span></span> <span data-ttu-id="97f4a-130">Außerdem wird für die Transaktion dadurch allmählich ein Upgrade von einer Lesetransaktion zu einer Schreibtransaktion durchgeführt, wie es von den jeweiligen Befehlen erfordert wird.</span><span class="sxs-lookup"><span data-stu-id="97f4a-130">It also causes the transaction to gradually upgrade from a read transaction to a write transaction as needed by its commands.</span></span> <span data-ttu-id="97f4a-131">Dies kann hilfreich sein, wenn während der Transaktion gleichzeitiger Zugriff auf die Datenbank ermöglicht werden soll.</span><span class="sxs-lookup"><span data-stu-id="97f4a-131">This can be useful for enabling concurrent access to the database during the transaction.</span></span>

[!code-csharp[](../../../../samples/snippets/standard/data/sqlite/DeferredTransactionSample/Program.cs?name=snippet_DeferredTransaction)]

> [!WARNING]
> <span data-ttu-id="97f4a-132">Bei Befehlen innerhalb einer verzögerten Transaktion können Fehler auftreten, wenn sie dazu führen, dass für die Transaktion ein Upgrade von einer Lesetransaktion zu einer Schreibtransaktion durchgeführt wird, noch während die Datenbank gesperrt ist.</span><span class="sxs-lookup"><span data-stu-id="97f4a-132">Commands inside a deferred transaction can fail if they cause the transaction to be upgraded from a read transaction to a write transaction while the database is locked.</span></span> <span data-ttu-id="97f4a-133">Wenn dies geschieht, muss die Anwendung die gesamte Transaktion neu ausführen.</span><span class="sxs-lookup"><span data-stu-id="97f4a-133">When this happens, the application will need to retry the entire transaction.</span></span>
